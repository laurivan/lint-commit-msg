#!/usr/bin/env bash
sa_version="v0.2.0"
sa_version_string="simpleargs v0.2.0 build 1d525e6 (2023-01-13 19:46:18 UTC)"
sa_version_hash="1d525e6"

#----- benchmark -----#
#!/usr/bin/env bash

# Utility to allow a function to return a value by either echoing it
# or by storing it into a variable. Normally the value is echoed but
# if variable "__retname" is defined the value is stored into a variable
# whose name is the contents of __retname. So, if a function is defined as
#
# foo() {
#   local result="..."
#   echo_or_store "${result}"
# }
#
# and one wants to get the result value into a variable (instead of echoing it):
#
# __retname=fooResult foo
# doSomething "${fooResult}"
sa_echo_or_store() {
    local __retval="$1"
    local __retcode="${2:-0}"
    if [ -n "$__retname" ]
    then
        declare -n return_tmp="${__retname}"
        return_tmp="${__retval}"
    else
        echo "$__retval"
    fi
    return "$__retcode"
}

# Return current time in milliseconds
sa_current_time_millis() { sa_echo_or_store $(date +%s%3N); }

# Stopwatch usage:
# sa_stopwatch_reset important
# for i in ...
# do
#     do-something
#     do-something-else
#
#     # Measure how much time is spent in 'do-something-important'
#     sa_stopwatch_start important
#     do-something-important
#     sa_stopwatch_stop important
# done
# sa_stopwatch_print important # Prints e.g.: 4523 ms (important)

sa_stopwatch_start() {
    declare -n stopwatch_running=_stopwatch_running${1:+_$1}
    if [ "${stopwatch_running}" = "true" ]
    then
        echo "ERROR: Stopwatch already running${1:+ (${1})}" >&2
        return 1
    else
        stopwatch_running=true
        declare -n stopwatch_count=_stopwatch_count${1:+_$1}
        [ -n "${stopwatch_count}" ] || __retname=_stopwatch_count${1:+_$1} sa_echo_or_store 0
        __retname=_sa_stopwatch_start${1:+_$1} sa_current_time_millis
    fi
}

sa_stopwatch_stop() {
    declare -n stopwatch_running=_stopwatch_running${1:+_$1}
    if [ "${stopwatch_running}" != "true" ]
    then
        echo "ERROR: Stopwatch already stopped${1:+ (${1})}" >&2
        return 1
    else
        stopwatch_running=false
        declare -n stopwatch_count=_stopwatch_count${1:+_$1}
        declare -n stopwatch_start=_sa_stopwatch_start${1:+_$1}
        __retname="_stopwatch_count${1:+_$1}" sa_echo_or_store $(( ${stopwatch_count} + $(sa_current_time_millis) - ${stopwatch_start} ))
    fi
}

sa_stopwatch_print() {
    local namespace="$1"
    declare -n tmp_count=_stopwatch_count${namespace:+_${namespace}}
    printf "%s %4d ms${namespace:+ (${namespace})}\n" "-----" "${tmp_count}"
}

sa_stopwatch_reset() {
    declare -n stopwatch_running=_stopwatch_running${1:+_$1}
    declare -n stopwatch_count=_stopwatch_count${1:+_$1}
    stopwatch_running=false
    stopwatch_count=0
}

# Set _tic to current time
# $1: namespace of tic-toc watch (return variables are suffixed with _<namespace>)
sa_tic_time() {
    __retname=_tic${1:+_$1} sa_current_time_millis
}

# Add $1 (milliseconds) to current _tic
# $1: time to add to tic_time (in milliseconds)
# $2: namespace of tic-toc watch (return variables are suffixed with _<namespace>)
sa_tic_time_plus() {
    local added_time="$1"
    (( _tic${2:+_$2} = _tic${2:+_$2} + $added_time ))
}

# Set _toc to the time between _tic and the current time
# $1: namespace of tic-toc watch (return variables are suffixed with _<namespace>)
sa_toc_time() {
    __retname=_toctmp sa_current_time_millis
    (( _toc${1:+_$1} = $(sa_current_time_millis) - _tic${1:+_$1} ))
}

# Set toc_time to the time between tic_time and current time
# and set tic_time to current time
# $1: namespace of tic-toc watch (return variables are suffixed with _<namespace>)
sa_toc_tic_time() {
    sa_toc_time $1
    sa_tic_time $1
}

sa_print_toc_time() {
    local namespace="$1"
    declare -n tmp_toc=_toc${namespace:+_${namespace}}
    printf "%s %4d ms${namespace:+ (${namespace})}\n" "-----" "${tmp_toc}"
}

sa_toc_and_print() {
    local namespace="$1"
    sa_toc_time "${namespace}"
    sa_print_toc_time "${namespace}"
}

sa_ms2s() {
    local ms="$1"
    [ ${#ms} -lt 4 ] && { ms="0000${ms}"; ms=${ms: -4}; }
    sa_echo_or_store "${ms:0:-3}.${ms: -3}"
}

# Example:
# sa_tic_time; sleep 1.34; sa_toc_time; sa_ms2s $_toc
# -> prints e.g. 1.346
#
# OR
# sa_tic_time mytimer; sleep 0.46; sa_toc_time mytimer; sa_ms2s $_toc_mytimer
# -> prints e.g. 0.468

#----- simpleargs-main -----#
#!/usr/bin/env bash
# simpleargs-main

# sa_toc_time call is inserted by the build (see bin/build) to the end of the bundle.
sa_tic_time sourcing_simpleargs

[ -z "${HOME}" ] && {
    echo "ERROR: \${HOME} is not set" >&2
    exit 1
}
[ -d "${HOME}" ] || {
    echo "ERROR: \${HOME} is not a directory: ${HOME}" >&2
    exit 1
}

# By default '-p/--tcp-port 8080' initializes '$p' and '$tcp_port' (not e.g. '$_p')
sa_varname_prefix=""
sa_config_dir=${HOME}/.simpleargs.d
sa_cached_options_dir="${sa_config_dir}/cached"
sa_manpage_dir="${sa_config_dir}/bin/man/man1"
sa_completed_scripts_dir="${sa_config_dir}/completed-scripts"
sa_tmp_dir="${sa_config_dir}/tmp"

# Configuration options
sa_user_settings="${sa_user_settings:-${HOME}/.simpleargs.conf}"
sa_global_settings="${sa_global_settings:-/etc/simpleargs.conf}"
if [ -f "${sa_user_settings}" ]
then
    . "${sa_user_settings}" || return 1
fi
if [ -f "${sa_global_settings}" ]
then
    . "${sa_global_settings}" || return 1
fi

# After parsing argument definitions write the resulting data structures into
# a cache file. When invoking the script again check if the the cache file is
# up to date (newer than the script file itself) and if yes, read the cache
# file instead of parsing the definitons again.
sa_use_cache=${sa_use_cache:-true}
# Use the argument definitions to generate a manual page for the script.
sa_generate_man_page=${sa_generate_man_page:-true}
# Use the argument definitions to generate Bash completion rules for the script.
sa_use_completion=${sa_use_completion:-true}
# Terminate the script after parsing the argument definitions. This can be used
# e.g. to update the manual page of the script. That is, invoking the script like
# > sa_parse_only=true my-command
# will write the cache file, manual page and Bash completion rules but does not
# execute the script further.
sa_parse_only=${sa_parse_only:-false}
# Exit the script if parsing the argument definitions fails. Exiting the script
# is the default behaviour and should only be changed for debugging purposes.
sa_exit_on_parse_failure=${sa_exit_on_parse_failure:-true}
# Exit the script if processing the (command line) arguments fail. That is, if
# the user provided erroneous arguments: e.g. missing positional parameters or
# invalid values for the options. Exiting the script is the default behaviour
# and should only be changed for debugging purposes.
sa_exit_on_process_failure=${sa_exit_on_process_failure:-true}
# What to do when processing of arguments fails: 'none', 'display-usage' or
# 'display-synopsis'
sa_process_failure_action=${sa_process_failure_action:-display-synopsis}
# Turn on printing of benchmark figures of certain simpleargs library functions.
sa_benchmark=${sa_benchmark:-false}
# Logging level used by the logging library. The logging library is used
# internally by simpleargs but can also be used by the user script.
log_level=${log_level:-WARN}
# The maximum number of items to print in an error message for an argument
# that defines a set of valid values.
sa_print_max_valid_values=${sa_print_max_valid_values:--1}
# The maximum number of characters for items to print in an error message
# for an argument that defines a set of valid values.
sa_print_max_valid_values_length=${sa_print_max_valid_values_length:--1}
# The maximum number of tokens that sa_parse will handle. This value is provided
# to provide rudimentary detection for infinite recursion when using expand tokens.
# For example, @expand=foo --> @expand=bar and @expand=bar --> @expand=foo would
# otherwise cause the parsing never to terminate.
sa_max_tokens=${sa_max_tokens:-2000}

sa_expand_token_help=( "-h/--help" "@doc=Print usage instructions and exit." "@afterprocessing=sa_display_usage; exit 0" )
sa_expand_token_version=( "--version" "@doc=Display version information." "@afterprocessing=sa_display_version; exit 0" )
#sa_expand_token_log_level=( "--log-level" "OFF,ERROR,WARN,INFO,CONFIG,FINE,FINER,FINEST,ALL" "@default=INFO" "@after" )

# Disable tty logging (used by auto completion functions)
_sa_tty_echo() { :; }

sa_end_parse() {
    sa_parse_status="$1"
    [ "${sa_parse_status}" -eq "${sa_parse_status}" ] ||
        { echo "Usage: ${FUNCNAME} <sa_parse exit status>" >&2; exit 1; }

    if [ "${sa_parse_status}" -eq 0 ]
    then
        log FINE "${FUNCNAME}: parsing successful"
    else
        log FINE "Failed to parse argument definitions (${FUNCNAME} exit status: ${sa_parse_status})"
        case "${sa_parse_status}" in
            127)
                log ERROR "Check that your argument definitions have the necessary backslashes and no trailing whitespace"
                ;;
        esac

        if ${sa_exit_on_parse_failure}
        then
            log FINE "Parse failure: exiting"
            exit "${sa_parse_status}"
        else
            log FINE "sa_exit_on_parse_failure=false, not exiting on parse failure"
        fi
    fi

    if ${sa_parse_only}
    then
        log INFO "sa_parse_only='true': exiting after parsing argument definitions"
        exit "${sa_parse_status}"
    fi
    return "${sa_parse_status}"
}

sa_end_process() {
    sa_process_status="$1"
    [ "${sa_process_status}" -eq "${sa_process_status}" ] ||
        { echo "Usage: ${FUNCNAME} <sa_process exit code>" >&2; exit 1; }

    if [ "${sa_process_status}" -eq 0 ]
    then
        log FINE "${FUNCNAME}: (argument) processing successful"
    else
        log FINE "Failed to process arguments (${FUNCNAME} exit status: ${sa_process_status})"
        case "${sa_process_failure_action}" in
            none)
                :
                ;;
            display-usage)
                sa_display_usage >&2
                ;;
            display-synopsis)
                echo "${sa_synopsis_text}" >&2
                ;;
        esac

        if ${sa_exit_on_process_failure}
        then
            log FINE "Process failure: exiting"
            exit "${sa_process_status}"
        else
            log FINE "sa_exit_on_process_failure=false, not exiting on process failure"
        fi
    fi
    return "${sa_process_status}"
}

sa_parse() {
    sa_tic_time $FUNCNAME
    log CONFIG "${sa_version_string}"
    # Set script path (used for comparing script's timestamp to the cache file)
    sa_script_path="$1"
    log CONFIG "Script path: '${sa_script_path}'"

    # Set script basename (used e.g. for deducing cache file name)
    sa_script_name="$(basename $1)"
    log CONFIG "Script name: '${sa_script_name}'"
    shift # Don't try to parse script name as an option

    # Try to read from cache (if enabled). Certain error return codes from
    # sa_read_from_cache don't signal an actual error but merely that the
    # options need to be parsed (and afterwards are possibly written to cache).
    if [ "${sa_parse_only}" = "true" ]
    then
        log CONFIG "sa_parse_only=${sa_parse_only}: not using cache"
    elif [ "${sa_use_cache}" = "true" ]
    then
        sa_read_from_cache "${sa_script_name}"
        local read_cache_retcode=$?
        case "${read_cache_retcode}" in
            0)
              # These are corner cases but check completion and man page mechanisms even if cache is read successfully.
              [ "$sa_use_completion" = true ] && { sa_use_completion "$sa_script_name" || return; }
              [ "$sa_generate_man_page" = true ] && { sa_generate_man_page "$sa_script_name" "${sa_script_path}" || return; }
              log CONFIG "Read options from cache, returning..."
              sa_toc_time ${FUNCNAME}; [ "${sa_benchmark}" = "true" ] && sa_print_toc_time ${FUNCNAME}
              return 0
              ;;
            10|11|12)
              log CONFIG "Could not read options from cache: parsing them..."
              ;;
            *)
              log ERROR "Unexpected error code (${read_cache_retcode}) while trying to read from cache"
              sa_toc_time ${FUNCNAME}; [ "${sa_benchmark}" = "true" ] && sa_print_toc_time ${FUNCNAME}
              return "${SA_PARSE_CANNOT_READ_CACHE}"
        esac
    else
        log CONFIG "Cache disabled (sa_use_cache='${sa_use_cache}')"
    fi

    # Array storing the option fullnames (and their order).
    declare -ag sa_options=() # e.g. ("-b/baudrate" "-h" "--port" ...)

    # Array storing option flag definitions (separating short and long form
    # for any given option) for detecting duplicate flag definitions.
    declare -ag sa_flags=() # e.g. ("-b" "--baudrate" "-h" "--port" ...)

    # Array storing the mapnames (and their order).
    declare -ag sa_optionmaps=() # e.g. ("sa_option_b__baudrate" "sa_option_h" ...)

    # Map from flags to options' fullnames
    # [-b]="-b/--baudrate"
    # [--baudrate]="-b/--baudrate"
    # [-h]="-h"
    # [--port]="--port
    declare -Ag sa_fullnames=()

    # Map from flags and fullnames to option map names
    # [-b]="sa_option_b__baudrate"
    # [--baudrate]="sa_option_b__baudrate"
    # [-b/--baudrate]="sa_option_b__baudrate"
    # [-h]="sa_option_h"
    declare -Ag sa_mapnames=()

    # Array storing the (raw) positional parameter definitions (and their order).
    declare -ag sa_params=() # e.g. ("<input file>" "<output file>" "[<log file>]")

    # Running number that is used in parameter identifiers to ensure their uniqueness.
    declare -g sa_param_counter=0

    # Array storing the mapnames (and their order).
    declare -ag sa_parammaps=() # e.g. ("sa_param_input_file" "sa_param_output_file" ...)

    # Array storing all variable names (from both options and parameters).
    declare -ag sa_varnames=() # e.g. ("b", "baudrate", "port", ... , "input_file")

    # Running index (per entry) for validation commands
    declare sa_validation_command_index
    declare -Ag sa_validation_command_modifiers=()

    # Arrays storing short and long option strings (for getopt)
    declare -ag sa_shortopt_strings=() # e.g. ("b:", "h", "d::", "g", ...)
    declare -ag sa_longopt_strings=() # e.g. ("baudrate:", "help", "delta::", "group-on", ...)

    # Set default "library tokens" to be parsed alongside with sa_parse arguments
    local sa_default_tokens_status
    sa_default_tokens_status=$(declare -p sa_default_tokens 2>/dev/null)
    if [ $? -eq 0 ]
    then
        if [ "${sa_default_tokens_status}" = "declare -a sa_default_tokens=()" ]
        then
            log FINE "Variable 'sa_default_tokens' set to an empty array"
        elif [[ "${sa_default_tokens_status}" = 'declare -- sa_default_tokens="'*'"' ]]
        then
            log ERROR "Variable 'sa_default_tokens' set to string: '${sa_default_tokens}'"
            log ERROR "Override by setting to an array value e.g. sa_default_tokens=()"
            return "${SA_PARSE_INVALID_ARGUMENTS}"
        else
            log FINE "Variable 'sa_default_tokens' set to a custom array"
        fi
    else
        log FINE "sa_default_tokens not defined: using the default 'default tokens'"
        declare -a sa_default_tokens=( @expand=help )
    fi
    log_vars FINE sa_default_tokens_status sa_default_tokens

    # Argument definition parsing state machine
    declare -Ag parsing_state=()
    # Option transition restrictions
    parsing_state+=( [accept_option]=true )
    parsing_state+=( [accept_argplaceholder]=false )
    parsing_state+=( [accept_validationargument]=false )
    parsing_state+=( [accept_directive]=false )
    parsing_state+=( [accept_validation]=false )
    parsing_state+=( [accept_endofoptions]=true )
    # Parameter transition restrictions
    parsing_state+=( [accept_param]=true )
    parsing_state+=( [accept_optionalparam]=true )
    parsing_state+=( [accept_varparam]=true )
    parsing_state+=( [accept_varoptionalparam]=true )
    # Recording state (ready to trigger finalizing of an option or a parameter)
    parsing_state+=( [recording_option]=false )
    parsing_state+=( [recording_param]=false )

    local arg token token_type token_number=0
    local previous_token previous_token_type
    declare -a token_queue=()
    log CONFIG "---------- Parsing options and parameters ----------"
    for arg in "${sa_default_tokens[@]}" "$@"
    do
        token_queue+=( "${arg}" )
        while [ ${#token_queue[@]} -gt 0 ]
        do
            if [ "${token_number}" -ge "${sa_max_tokens}" ]
            then
                log ERROR "Maximum number of tokens reached: ${sa_max_tokens}"
                log ERROR "This may be caused by recursively (infinitely) expanding expand tokens:"
                log ERROR "  e.g. For example, @foo@ --> @bar@ and @bar@ --> @foo@"
                log ERROR "If more tokens are actually required use e.g. 'sa_max_tokens=1500'"
                return "${SA_PARSE_INVALID_ARGUMENTS}"
            fi
            token="${token_queue[0]}"; unset token_queue[0]; token_queue=( "${token_queue[@]}" )
            token_type="unknown"
            log FINE "Handling token ${token_number}: '${token}'"
            ((token_number++))
            # Deduce token type
            # NOTE! The order of conditions is significant: start with the most specific one.
            if [ "${token}" = "--" ]; then
                # --
                token_type=endofoptions
            elif [[ "${token}" = -* ]] && [[ "${token}" != ---* ]]; then
                # -p/--port
                token_type=option
            elif [[ "${token}" = "<"*"...>" ]] ||
                     [[ "${token}" = "[<"*"...>]" ]] ||
                     [[ "${token}" = "[<"*">...]" ]] ||
                     [[ "${token}" = "<["*"]>" ]] ||
                     [[ "${token}" = "<["*"...]>" ]] ||
                     [[ "${token}" = "<["*"]...>" ]]; then
                # Give a helpful error message in case of invalid
                # (mistyped or misremembered) parameter syntax
                #   <input file...>
                #   [<input file...>]
                #   [<input file>...]
                #   <[input file>]
                #   [<input file...>]
                #   [<input file>...]
                log ERROR "Invalid syntax: \"${token}\", valid parameter definitions:"
                log ERROR "           normal: \"<param>\""
                log ERROR "         optional: \"[<param>]\""
                log ERROR "          varargs: \"<param>...\""
                log ERROR " varargs optional: \"[<param>]...\""
                return "${SA_PARSE_INVALID_ARGUMENTS}"
            elif [[ "${token}" = "<"*">" ]]; then
                # <input file>
                token_type=param
            elif [[ "${token}" = "[<"*">]" ]]; then
                # [<log file>]
                token_type=optionalparam
            elif [[ "${token}" = "<"*">..." ]]; then
                # <input file>...
                token_type=varparam
            elif [[ "${token}" = "[<"*">]..." ]]; then
                # [<input file>]...
                token_type=varoptionalparam
            elif [[ "${token}" =~ ^@expand=[A-Za-z_]+$ ]]; then
                local expand_token_name=${token:8}
                local expanded_tokens_varname="sa_expand_token_${expand_token_name}"
                declare -n expanded_tokens="${expanded_tokens_varname}"
                # Should never happen since expand_token_name is always a valid identifier
                #if [ $? -ne 0 ]
                #then
                #    log ERROR "Invalid expand token name: '${expand_token_name}'"
                #    log ERROR "Expand token should match '^@[a-z_]+@$'"
                #    return "${SA_PARSE_INVALID_ARGUMENTS}"
                #fi
                if [ ${#expanded_tokens[@]} -eq 0 ]
                then
                    log ERROR "No such expand token (or an empty array): '${expand_token_name}'"
                    log ERROR "Use e.g. '${expanded_tokens_varname}=( value1 value2 )' to define it."
                    return "${SA_PARSE_INVALID_ARGUMENTS}"
                fi

                token_queue=( "${expanded_tokens[@]}" "${token_queue[@]}" )
                log FINER "Expanded ${#expanded_tokens[@]} tokens from expand token: '${token}'"
                continue
            elif [[ "${token}" = @@@skiprest ]]; then
                # @@@@
                log FINER "Skipping rest of the tokens: '${token}' (starts with '@@@@')"
                break 2
            elif [[ "${token}" = @@@* ]]; then
                # @@@
                log FINER "Skipping dummy token '${token}' (starts with '@@@')"
                continue
            elif [[ "${token}" = @@* ]]; then
                # @@glob
                token_type=validation
            elif [[ "${token}" = @* ]]; then
                # @doc
                token_type=directive
            else
                if ${parsing_state[accept_argplaceholder]}
                then
                    # Type:          Example value:         Shortcut for:
                    # -----------------------------------------------------------
                    # Valid values:  low,medium,high        @validvalues%=low%medium%high
                    # Variable name: port                   @varname=port
                    # Glob:          '*.jpg'                @glob='*.jpg'
                    token_type=argplaceholder
                elif ${parsing_state[accept_validationargument]}
                then
                    token_type=validationargument
                else
                    log ERROR "Invalid token '${token}' (${token_type})${previous_token_type:+ after token '${previous_token}' (${previous_token_type})}"
                    return "${SA_PARSE_INVALID_ARGUMENTS}"
                fi
            fi

            # Enforce state transition rules
            log_vars_in_map FINEST parsing_state
            if ${parsing_state["accept_${token_type}"]}
            then
                log FINER "Reading token '${token}' (${token_type})"
            else
                log ERROR "Invalid token '${token}' (${token_type})${previous_token_type:+ after token of type '${previous_token_type}'}"
                return "${SA_PARSE_INVALID_ARGUMENTS}"
            fi
            plus_indent

            # Finalize (store) validation command
            if ${parsing_state[accept_validationargument]} && [ "${token_type}" != validationargument ]
            then
                log FINER "Triggerin finalizing of a validation command"
                sa_finalize_validation_command
                parsing_state[accept_validationargument]=false
            fi

            # Finalize (store) options and parameters
            if ${parsing_state[recording_option]} && [ "${token_type}" != argplaceholder ] &&
                    [ "${token_type}" != directive ] &&
                    [ "${token_type}" != validation ] &&
                    [ "${token_type}" != validationargument ]
            then
                log FINER "Triggering finalizing of an option"
                sa_finalize_option
                parsing_state[recording_option]=false
                parsing_state[accept_directive]=false
                parsing_state[accept_validation]=false
            fi
            if ${parsing_state[recording_param]} && [ "${token_type}" != directive ] &&
                    [ "${token_type}" != validation ] &&
                    [ "${token_type}" != validationargument ]
            then
                log FINER "Triggering finalizing of a parameter"
                sa_finalize_param
                parsing_state[recording_param]=false
                parsing_state[accept_directive]=false
                parsing_state[accept_validation]=false
            fi

            # Validation command argument can only follow a validation
            # directive (or another validation command argument)
            if [ "${token_type}" = validation ]
            then
                log FINER "Token type is 'validation': next token can be a validation argument"
                parsing_state[accept_validationargument]=true
            fi

            # Arg(ument) placeholder token types can only follow an option
            if [ "${token_type}" = option ]
            then
                log FINER "Token type is 'option': next token can be an argument placeholder"
                parsing_state[recording_option]=true
                parsing_state[accept_argplaceholder]=true
                parsing_state[accept_directive]=true
                parsing_state[accept_validation]=true
            else
                log FINER "Token type is not 'option': next token cannot be an argument placeholder"
                parsing_state[accept_argplaceholder]=false
            fi

            if [[ "${token_type}" =~ .*param|endofoptions ]]
            then
                log FINER "Token type (${token_type}) is '*param' or 'endofoptions': not accepting options anymore"
                parsing_state[accept_option]=false
                parsing_state[accept_endofoptions]=false
            fi

            if [[ "${token_type}" = *param ]]
            then
                log FINER "Token type is ${token_type}: recording parameter..."
                parsing_state[recording_param]=true
                parsing_state[accept_directive]=true
                parsing_state[accept_validation]=true
            fi

            case "${token_type}" in
                optionalparam)
                    log FINER "Token type is ${token_type}: not accepting subsequent mandatory parameters"
                    parsing_state[accept_param]=false
                    parsing_state[accept_varparam]=false
                    ;;
                varparam|varoptionalparam)
                    log FINER "Token type is ${token_type}: not accepting subsequent parameters"
                    parsing_state[accept_param]=false
                    parsing_state[accept_optionalparam]=false
                    parsing_state[accept_varparam]=false
                    parsing_state[accept_varoptionalparam]=false
                    ;;
            esac

            # Parse token contents and update the current entry (option or parameter) accordingly
            log FINER "Parsing token '${token}' (${token_type})"
            sa_parse_${token_type} "${token}" || return
            previous_token_type="${token_type}"
            previous_token="${token}"
            minus_indent
        done # while [ ${#token_queue[@]} -gt 0 ]
    done # for arg in "${sa_default_tokens[@]}" "$@"

    # Finalize (store) validations, options and parameters, and finalize parsing
    ${parsing_state[accept_validationargument]} && { sa_finalize_validation_command || return; }
    ${parsing_state[recording_option]} && { sa_finalize_option || return; }
    ${parsing_state[recording_param]} && { sa_finalize_param || return; }
    sa_finalize_parsing || return
    log CONFIG "Parsing options finished successfully"

    # Write cache, command completion and man page files (if enabled)
    [ "$sa_use_cache" = true ] && { sa_write_to_cache "$sa_script_name" || return; }
    [ "$sa_use_completion" = true ] && { sa_use_completion "$sa_script_name" || return; }
    [ "$sa_generate_man_page" = true ] && { sa_generate_man_page "$sa_script_name" "${sa_script_path}" || return; }

    sa_toc_time ${FUNCNAME}; [ "${sa_benchmark}" = "true" ] && sa_print_toc_time ${FUNCNAME}
    return 0
}

# Adds a marked directory the existence of which is checked when sourcing simpleargs.rc
# (see especially function sa-refresh-completion). If there's a marker directory 'xyz'
# is found the script 'xyz' will be configured to use simpleargs completion routines.
sa_use_completion() {
    local script_name="$1"
    log FINE "Checking '${script_name}' for addition to completed scripts: '${sa_completed_scripts_dir}'"
    if [ -d "${sa_completed_scripts_dir}/${script_name}" ]
    then
        log FINE "Script already included in completed scripts"
    else
        log FINE "Adding '${script_name}' to completed scripts"
        mkdir -p "${sa_completed_scripts_dir}/${script_name}" || return
    fi
}

sa_finalize_validation_command() {
    sa_add_validation "${sa_validation_command_words[@]}"
    unset sa_validation_command_words
}

# Creates the final map that holds the data for this option and copies the attributes
# from map 'option' the final map (e.g. 'sa_option_b__baudrate').
sa_finalize_option() {
    log FINER "Finalizing an option: '${clientry[fullname]}'"
    plus_indent

    if [ -n "${clientry[implicit_varname]}" ] && [ -n "${clientry[explicit_varname]}" ]
    then
        log ERROR "${clientry[fullname]}: cannot have both implicit (${clientry[implicit_varname]}) and explicit variable name (${clientry[explicit_varname]})"
        return "${SA_PARSE_INVALID_ARGUMENTS}"
    fi
    [ -n "${clientry[implicit_varname]}" ] && clientry[varname]="${clientry[implicit_varname]}"
    [ -n "${clientry[explicit_varname]}" ] && clientry[varname]="${clientry[explicit_varname]}"

    # Finalize option type
    # - If there is some kind of validation logic or a default value -> change to 'value' type
    # - @optionalvalue set --> optionalvalue
    # - @multivalue --> multivalue (remember to set list separator if necessary)
    if [ -n "${clientry[validationarraynames]}" ] ||
           [ -n "${clientry[validvaluesarray]}" ] ||
           [ -n "${clientry[validvaluesfile]}" ] ||
           [ -n "${clientry[validvaluescommand]}" ] ||
           [ -n "${clientry[default]}" ]
    then
        clientry[type]=value
        clientry[getopt_type]=":"
    fi
    [ -n "${clientry[optionalvalue]}" ] && { clientry[type]=optionalvalue; clientry[getopt_type]="::"; }
    [ -n "${clientry[multivalue]}" ] && { clientry[type]=multivalue; clientry[getopt_type]=":"; }
    [ "${clientry[type]}" = novalue ] && clientry[default]=false # Set implicit default
    minus_indent

    if [ "${clientry[allowrepeat]}" = true ] && [ "${clientry[type]}" != novalue ]
    then
        log ERROR "${clientry[fullname]}: @allowrepeat directive can only be used with novalue options"
        return "${SA_PARSE_INVALID_ARGUMENTS}"
    fi

    plus_indent
    # Deduce to which variable names to assign values
    if [ -n "${clientry[varname]}" ]
    then
        # Variable name specified -> this is the only variable assigned
        clientry[flagvars]="${clientry[varname]}"

        declare -n sa_varname_test_variable="${clientry[varname]}" 2>/dev/null || {
            log ERROR "Invalid variable name '${clientry[varname]}'"
            log ERROR "Variable names should match regexp [a-zA-Z0-9_][a-zA-Z0-9_]*"
            return "${SA_PARSE_INVALID_ARGUMENTS}"
        }
    else
        # Use variable names formed from flag names
        # "-s -p --ssh-port" -> "s p ssh_port" (strip leading dashes and convert the rest of the dashes into underscores)
        clientry[flagvars]="$(sed -r -e "s/(^| )--?/\1${sa_varname_prefix}/g" -e 's/-/_/g' <<< "${clientry[flags]}")"
    fi

    # If the option variable name is derived from the flag name it might be
    # invalid: flags '-2' and '--2nd' produce invalid variable names because
    # of the leading number.
    local varname
    for varname in ${clientry[flagvars]}
    do
        declare -n sa_varname_test_variable="${varname}" 2>/dev/null || {
            log ERROR "Invalid variable name '${varname}'"
            log ERROR "Variable names should match regexp [a-zA-Z0-9_][a-zA-Z0-9_]*"
            log ERROR "Consider using '@varname=myvar' to explicitly set the variable name."
            return "${SA_PARSE_INVALID_ARGUMENTS}"
        }
    done

    local repeat_count_variables=""
    if [ "${clientry[allowrepeat]}" = true ]
    then
        log FINEST "Adding repeat count variables for ${clientry[fullname]}"
        for varname in ${clientry[flagvars]}
        do
            repeat_count_variables="${varname}_count "
        done
    fi

    log FINEST "Checking for conflicting variable names (flagvars: '${clientry[flagvars]}')"
    for varname in ${clientry[flagvars]} ${repeat_count_variables}
    do
        log FINEST "Checking variable name: '${varname}'"
        if sa_array_contains sa_varnames "${varname}"
        then
            log ERROR "Variable name for ${clientry[fullname]} already in use: '${varname}'"
            return "${SA_PARSE_INVALID_ARGUMENTS}"
        else
            sa_varnames+=("${varname}")
        fi
    done
    minus_indent

    # Append getopt option strings
    local flag
    for flag in ${clientry[flags]}
    do
        if [[ "${flag}" = --* ]]
        then
            sa_longopt_strings+=( "${flag:2}${clientry[getopt_type]}" )
        elif [[ "${flag}" = -* ]]
        then
            sa_shortopt_strings+=( "${flag:1}${clientry[getopt_type]}" )
#        else
#            # Should never reach this block ('sa_record_option_definition' already checks the flags)
#            log ERROR "Unexpected flag definition: '${flag}'"
#            return "${SA_PARSE_INVALID_ARGUMENTS}"
        fi
    done

    # "Persist" option attributes
    sa_map_copy clientry ${clientry[mapname]}
    sa_array_copy docs ${clientry[docarray]}
    unset clientry
}

sa_finalize_param() {
    log FINER "Finalizing a parameter: '${clientry[fullname]}'"
    plus_indent

    declare -n sa_varname_test_variable="${clientry[varname]}" 2>/dev/null || {
        log ERROR "Invalid variable name '${clientry[varname]}'"
        log ERROR "Variable names should match regexp [a-zA-Z0-9_][a-zA-Z0-9_]*"
        log ERROR "Consider using '@varname=myvar' to explicitly set the variable name."
        return "${SA_PARSE_INVALID_ARGUMENTS}"
    }

    if sa_array_contains sa_varnames "${clientry[varname]}"
    then
        log ERROR "Variable name for parameter '${clientry[fullname]}' already in use: '${clientry[varname]}'"
        return "${SA_PARSE_INVALID_ARGUMENTS}"
    else
        sa_varnames+=("${clientry[varname]}")
    fi

    clientry[mapname]=sa_param_${clientry[varname]}
    sa_parammaps+=(${clientry[mapname]})
    sa_map_copy clientry ${clientry[mapname]}
    sa_array_copy docs ${clientry[docarray]}

    minus_indent
    # Clear the data model: this enables sa_state_change to deduce whether a parameter needs to be saved.
    unset clientry
}

sa_init_clientry() {
    log FINEST "Initializing a new CLI entry"
    unset clientry validation
    sa_validation_command_index=0

    # A map of CLI entry attributes
    declare -Ag clientry=()
    # An array of validation rules (regexp, function)
    declare -ag validation=()
    # An array of documentation paragraphs (specified using @doc directive)
    declare -ag docs=()
}

sa_finalize_parsing() {
    log FINER "Finalizing parsing"
    # See http://stackoverflow.com/questions/1527049/join-elements-of-an-array
    # For some reason this does NOT work using '@' as the "array index"
    sa_getopt_short_options=$(IFS=,; echo "${sa_shortopt_strings[*]}")
    sa_getopt_short_options="${sa_getopt_short_options//,}" # Remove commas
    sa_getopt_long_options=$(IFS=,; echo "${sa_longopt_strings[*]}")
    log_vars FINER "# getopt strings" sa_getopt_short_options sa_getopt_long_options

    # Precompute the "completable" flags and save in cache. For long flags that take
    # an optional value one must one must include e.g. '--sort' but also '--sort='.
    log FINEST "Generating \"completable\" flags for Bash completion"
    local optionmap_name flag
    sa_completable_flags=""
    for optionmap_name in ${sa_optionmaps[@]}
    do
        declare -n option="${optionmap_name}"
        for flag in ${option[flags]}
        do
            if [ "${option[type]}" = "optionalvalue" ] && [[ "${flag}" = --* ]]
            then
                sa_completable_flags="${sa_completable_flags} ${flag} ${flag}="
            else
                sa_completable_flags="${sa_completable_flags} ${flag}"
            fi
        done
    done
    sa_completable_flags="${sa_completable_flags:1}" # Strip leading space
    log_vars FINER "# Variables for Bash completion" sa_completable_flags

    sa_build_usage_instructions
}

#----- simpleargs-constants -----#
#!/usr/bin/env bash
# simpleargs-constants

SA_PARSE_INVALID_ARGUMENTS=2
SA_PARSE_CANNOT_READ_CACHE=8
SA_PARSE_INTERNAL_ERROR=9
SA_PROCESS_INVALID_ARGUMENTS=2
SA_PROCESS_VALIDATION_FAILED=3
SA_PROCESS_GETOPT_FAILED=4
SA_PROCESS_HOOK_FAILURE=5
SA_PROCESS_INTERNAL_ERROR=9
SA_INTERNAL_ERROR=11
SA_INCORRECT_USE=12
SA_GENERATED_ERROR_MSG_STATUS=14
SA_USAGE_INSTRUCTIONS_EMPTY=15

#----- log -----#
#!/usr/bin/env bash

echo_invalid_log_level() {
    local log_level="$1"
    echo "No such log level: '${log_level}'"
    echo "Allowed log levels: OFF, ERROR, WARN, INFO, CONFIG, FINE, FINER, FINEST, ALL)."
}

sa_previous_log_level=""
# Invoked before making a decision whether to log a particular event: see function 'log_enabled'.
refresh_effective_log_level() {
    if [ "${log_level}" != "${sa_previous_log_level}" ]
    then
        if [ "${log_level}" -eq "${log_level}" ] 2>/dev/null
        then
            # Numeric log level
            if [ "${log_level}" -lt 0 ]
            then
                echo "Invalid (numeric) log level '${log_level}' used (should be >= 0): ignoring" >&2
            else
                [ -z "${original_log_level}" ] && original_log_level="${log_level}"
                effective_log_level=${log_level}
                effective_log_level_name=""
            fi
        else
            # Standard log level
            if [ -n "${_log_levels[${log_level}]}" ]
            then
                # Valid standard log level
                [ -z "${original_log_level}" ] && original_log_level=${_log_levels[${log_level}]}
                effective_log_level_name=${log_level}
                effective_log_level=${_log_levels[${log_level}]}
            else
                # Invalid (e.g. misstyped) log level
                echo_invalid_log_level "${log_level}" >&2
                echo "Setting log level to OFF." >&2
                effective_log_level_name=OFF
                effective_log_level=${_log_levels[${effective_log_level_name}]}
            fi
        fi

        # Save the previous log level: no need to update the effective log level until log_level is changed
        sa_previous_log_level="${log_level}"
    else
        : # Log level is up to date (no changes made by the user)
    fi
}

# Resets the log level to the first valid value that was set for the library.
reset_log_level() {
    log_level="${original_log_level}"
    refresh_effective_log_level
}

# Decides whether the log level of the message is higher than the (current) effective log level.
# Note! This function sets the variable '_msg_numeric_level' that can be used by the invoker
# e.g. for coloring the log message according to the message's log level.
log_enabled() {
    # Update effective numeric log level on every invocation to allow "on the fly"changes to log level.
    refresh_effective_log_level

    local msg_level="$1"
    if [ "${msg_level}" -eq "${msg_level}" ] 2>/dev/null
    then
        # Numeric message log level
        _msg_numeric_level=${msg_level}
    else
        # Standard message log level
        if [ -n "${_log_levels[${msg_level}]}" ]
        then
            _msg_numeric_level=${_log_levels[${msg_level}]}
        else
            echo_invalid_log_level "${msg_level}" >&2
            return 2
        fi
    fi

    [ "${_msg_numeric_level}" -ge "${effective_log_level}" ]
}

log() {
    local _msg_log_level="$1"; shift
    log_enabled "${_msg_log_level}" || return 0
    local __message="$1"; shift

    # '_msg_numeric_level' set by 'log_enabled'
    if [ "${_msg_numeric_level}" -ge "${_log_levels[ERROR]}" ]
    then
        color_escape=${_log_colors[Red]}
    elif [ "${_msg_numeric_level}" -ge "${_log_levels[WARN]}" ]
    then
        color_escape=${_log_colors[Yellow]}
    elif [ "${_msg_numeric_level}" -ge "${_log_levels[FINE]}" ]
    then
        color_escape=${_log_colors[Normal]}
    else
        color_escape=${_log_colors[Dark Gray]}
    fi

    # <date> <log level (6 char)> <indent> <custom format string>

    # Turn on font color (if enabled and output destination is terminal)
    if ${log_enable_colors} && ${_log_dest_opened_on_terminal}
    then
        echo -ne "\e[${color_escape}m" >&${log_dest}
    fi

    # Print timestamp (if enabled)
    if [ -n "${log_date_format}" ]
    then
        local timestamp="$(date "${log_date_format}")"
        printf "%s " "${timestamp}" >&${log_dest}
    fi

    # Print log level (if enabled)
    ${log_display_level} && printf "%${_log_level_field_width}s: " "${_msg_log_level}" >&${log_dest}
    # Print indent
    printf "%.*s" "${log_indent_amount}" "${log_spaces}" >&${log_dest}

    if [ $# -eq 0 ]
    then
        # Only one parameter (in addition to log level) -> simple (static) message
        printf -- "%s\n" "${__message}" >&${log_dest}
    else
        # More than one parameter: the message parameter is a printf format string
        local _format_string="${__message}"
        printf -- "${_format_string}" "$@" >&${log_dest}
    fi

    # Turn off font color (i.e. color back to normal)
    if ${log_enable_colors} && ${_log_dest_opened_on_terminal}
    then
        echo -ne "\e[${_log_colors[Normal]}m" >&${log_dest}
    fi
}

error() { log ERROR "$@"; }
warn() { log WARN "$@"; }
info() { log INFO "$@"; }
config() { log CONFIG "$@"; }
fine() { log FINE "$@"; }
finer() { log FINER "$@"; }
finest() { log FINEST "$@"; }

# TODO: correct indentation when printing arrays and maps
# TODO: prefix the variables with __sa_ (to avoid clashes)
# TODO: reset alignment after empty and separator lines?
# TODO: proper hangling of namerefs: https://stackoverflow.com/questions/14525296/how-do-i-check-if-variable-is-an-array
#  (see answer by Marco)
# TODO: log_vars_in_map and log_vars_in_array are basically the same -> refactor
log_vars() {
    local _msg_log_level="$1"; shift
    log_enabled "$_msg_log_level" || return 0

    local _name
    local _value
    local _longest_name_length=0
    for _name in "$@"
    do
        [ "${#_name}" -gt "${_longest_name_length}" ] && _longest_name_length="${#_name}"
    done
    for _name in "$@"
    do
        case "$_name" in
            " ")
                log "$_msg_log_level" ""
            ;;
            \#*)
                log "$_msg_log_level" "$(printf "%${_longest_name_length}s\n" "$_name" | sed -r 's/#/ /')"
            ;;
            *)
                if declare -p ${_name} 2>/dev/null | grep -q '^declare -a'
                then
                    log_vars_in_array "$_msg_log_level" "${_name}"
                elif declare -p ${_name} 2>/dev/null | grep -q '^declare -A'
                then
                    log_vars_in_map "$_msg_log_level" "${_name}"
                else
                    # http://mywiki.wooledge.org/BashFAQ/083
                    if [ -z "${!_name+defined}" ]
                    then
                        log "$_msg_log_level" "$(printf "%${_longest_name_length}s: %s\n" "$_name" "'' <undefined or an empty array>")"
                    else
                        _value=${!_name}
                        log "$_msg_log_level" "$(printf "%${_longest_name_length}s: %s\n" "$_name" "'${_value}'")"
                    fi
                fi
            ;;
        esac
    done
}

# log_vars_in_map <log level> <map name> [<key>...]
log_vars_in_map() {
    local _msg_log_level="$1"; shift
    log_enabled "$_msg_log_level" || return 0
    local _mapname="$1"; shift

    declare -p $_mapname 2> /dev/null | grep -q '^declare -A' || { echo "No such map: '$_mapname'"; return 1; }
    declare -n _map=$_mapname
    [ -z "$1" ] && set -- "${!_map[@]}"

    local name
    local value
    local name_lengths=""
    local _longest_name_length=0
    for name in "$@"
    do
        [ "${#name}" -gt "${_longest_name_length}" ] && _longest_name_length="${#name}"
    done
    ((_longest_name_length += 4 )) # Add 2 for brackets: '[' and ']', and 2 for indentation

    log "$_msg_log_level" "# ${_mapname}[@]"
    for name in "$@"
    do
        value=${_map[$name]}
        log "$_msg_log_level" "$(printf "%${_longest_name_length}s: %s\n" "[${name}]" "'${value}'")"
    done
}

log_vars_in_array() {
    local _msg_log_level="$1"; shift
    log_enabled "$_msg_log_level" || return 0
    local _arrayname="$1"; shift

    declare -p $_arrayname 2> /dev/null | grep -q '^declare -a' || { echo "No such array: '$_arrayname'"; return 1; }
    declare -n _array=$_arrayname
    [ -z "$1" ] && set -- "${!_array[@]}"

    local index
    local value
    local index_lengths=""
    local longest_index_length=0
    for index in "$@"
    do
        [ "${#index}" -gt "${longest_index_length}" ] && longest_index_length="${#index}"
    done
    ((longest_index_length += 4 )) # Add 2 for brackets: '[' and ']', and 2 for indentation

    log "$_msg_log_level" "# ${_arrayname}[@]"
    for index in "$@"
    do
        value=${_array[$index]}
        log "$_msg_log_level" "$(printf "%${longest_index_length}s: %s\n" "[${index}]" "'${value}'")"
    done
}

plus_indent() {
    ${log_indent_enabled} && (( log_indent_amount += log_indent_increment ))
}

minus_indent() {
    (( log_indent_amount -= log_indent_increment ))
    [ "$log_indent_amount" -lt 0 ] && log_indent_amount=0
    true
}

declare -Ag _log_levels=( [OFF]=100 [ERROR]=70 [WARN]=60 [INFO]=50 [CONFIG]=40 [FINE]=30 [FINER]=20 [FINEST]=10 [ALL]=0 )
# To add custom log levels:
# > _log_levels[FATAL]=80
# > log FATAL "Fatal test message."

declare -Ag _log_colors=( [Dark Gray]="1;30" [Blue]="0;34" [Green]="0;32" [Red]="0;31" [Yellow]="1;33" [Purple]="1;35" [White]="1;37" [Orange]="0;33" [Light Red]="1;31" [Normal]="00" )

# Default values...
effective_log_level_name=OFF
effective_log_level=${_log_levels[${effective_log_level_name}]}
# ...that are probably overwritten when first refreshing the log level.
refresh_effective_log_level

# Log date format as understood by 'date' command. An empty format string
# turns off printing of timestamp in log messages.
[ "${log_date_format}" = "time" ] && log_date_format="+%H:%M:%S.%3N"

log_spaces="                                                              "
# Whether to indent log messages. That is, only the message (not log level or date) is indented.
log_indent_enabled="${log_indent_enabled:-false}"
# Log message (initial) indentation that can be controlled with functions 'plus_indent' and 'minus_indent'.
log_indent_amount=0
# The width of indentation per call to 'plus_indent' and 'minus_indent'.
log_indent_increment=2
# Use colors (e.g. red for errors) in log messages.
log_enable_colors="${log_enable_colors:-true}"
# Print the log level alongside the log message.
log_display_level="${log_display_level:-true}"
# Align the "textual" log levels in log messages.
log_align_level="${log_align_level:-false}"

if "${log_align_level}"
then
    # The standard (textual) log levels fit in 6 characters
    #   INFO: Info message
    # CONFIG: Config message
    _log_level_field_width=${_log_level_field_width:-6}
else
    # Empty field width does not align log levels:
    # INFO: Info message
    # CONFIG: Config message
    _log_level_field_width=""
fi

# Log destination can be controlled using the following two variables:
# 1. 'log_dest': file descriptor to write to. Usually set to either '1' (stdout, default)
#    or '2' (stderr). To separate log output from stdout and stderr one can use other file
#    descriptors as well:
#    > log_dest=3 my-command 3>output-from-logging-library.txt
log_dest=${log_dest:-1}
# 2. 'log_file': file to write the log output. This overrides the value of 'log_dest'.
#    Usually it is simpler (and hence recommended) to use 'log_file' if one wishes to
#    redirect log output to a custom destination.
if [ -n "${log_file}" ]
then
    log_dest=16
    exec 16>"${log_file}"
fi

# Test whether the log output destination is "opened on a terminal".
# (Colored log messages are used only when outputting to a terminal.)
[ -t "${log_dest}" ] && _log_dest_opened_on_terminal=true || _log_dest_opened_on_terminal=false

#----- simpleargs-common-util -----#
#!/usr/bin/env bash
# simpleargs-common-util

# Prints one character that does not appear in strings given as arguments.
# The printed character can be used as e.g. sed delimiter character.
# For example, a hard coded delimiter '/' can fail unexpectedly:
# > myvar="value/with/slashes"
# > ... sed "s/${myvar}//" # Does not work
sa_safe_delimiter() {
    local delimiter
    for delimiter in '/' '|' '#' '@' '%' '+' {0..9} {a..z}
    do
        # Escape $delim_char ?
        [[ "$*" = *"${delimiter}"* ]] || break
    done
    echo -n "${delimiter}"
}

sa_print_stack_trace() {
    local frame=0
    while caller $frame
    do
        ((frame++));
    done
    echo "$*"
}

# Check if <value> is one of the arguments
# sa_args_contain <value> [<arg>...]
sa_args_contain() {
    local value="$1"; shift
    local arg
    for arg in "$@"
    do
        [ "$arg" = "$value" ] && return 0
    done
    return 1
}

# Check that array contains all the values
# sa_array_contains <array name> <value> [<value>...]
#
# Environment variable modifiers:
# - sa_transform_arrayvalue:
#   * '': simply compare array values to parameter values
#   * 'envsubst': replace environment variables in array values before comparing to parameter values
#   * 'eval': evaluate array values before comparing to parameter values
sa_array_contains() {
    local arrayname="$1"
    declare -n __array="$arrayname"
    shift

    local value
    for value in "$@"
    do
        local value_found=false
        local item_in_array
        for item_in_array in "${__array[@]}"
        do
            if [ "${sa_transform_arrayvalue}" = "" ]
            then
                [ "$item_in_array" = "$value" ] && { value_found=true; break; }
            elif [ "${sa_transform_arrayvalue}" = "envsubst" ]
            then
                [ "$(envsubst <<< "${item_in_array}")" = "$value" ] && { value_found=true; break; }
            elif [ "${sa_transform_arrayvalue}" = "eval" ]
            then
                [ "$(eval "${item_in_array}")" = "$value" ] && { value_found=true; break; }
            else
                log ERROR "Unknown value for sa_transform_arrayvalue: '${sa_transform_arrayvalue}'"
                return "${SA_INTERNAL_ERROR}"
            fi
        done
        $value_found || return 1
    done
    return 0
}

sa_map_contains_key() {
    local mapname="$1"
    local value="$2"
    local key
    declare -n __map="$mapname"
    for key in "${!__map[@]}"
    do
        [ "$key" = "$value" ] && return 0
    done
    return 1
}

sa_map_contains_value() {
    local mapname="$1"
    local value="$2"
    local value_in_map
    declare -n __map="$mapname"
    for value_in_map in "${__map[@]}"
    do
        [ "$value_in_map" = "$value" ] && return 0
    done
    return 1
}

sa_map_copy() {
    declare -n __source="$1"
    declare -Ag "$2"
    declare -n __dest="$2"
    log FINEST "Copying map: '$1' -> '$2'"
    local key
    for key in "${!__source[@]}"
    do
        log FINEST "Copying [$key]='${__source[$key]}'"
        __dest["$key"]="${__source[$key]}"
    done
}

sa_array_copy() {
    declare -n __source="$1"
    declare -ag "$2"
    declare -n __dest="$2"
    log FINEST "Copying array: '$1' -> '$2'"
    __dest=("${__source[@]}")
}

######### NOTE! ############
# See the warning in the beginning of simpleargs-process about variable naming and conventions.

# $1: value
# $2, $3, ...: variables
sa_assign() {
    local __sa_value="$1"; shift
    local __sa_variable

    for __sa_variable in "$@"
    do
        log FINEST "Assigning variable: ${__sa_variable}='${__sa_value}'${sa_transform_value:+ (transform: ${sa_transform_value})}"
        declare -g "${__sa_variable}" || { log ERROR "Invalid variable name: '${__sa_variable}'"; return 2; }
        # Temporary (name reference) to assign the value
        declare -n __sa_tmp_variable="${__sa_variable}"
        # Assign to name reference (and hence to the global variable defined above)
        [ "${sa_transform_value}" = "" ] && { __sa_tmp_variable="${__sa_value}"; continue; }
        [ "${sa_transform_value}" = "envsubst" ] && { __sa_tmp_variable="$(envsubst <<< "${__sa_value}")" || return; continue; }
        [ "${sa_transform_value}" = "eval" ] && { __sa_tmp_variable="$(eval "${__sa_value}")" || return; continue; }
    done
}

# $1: list e.g. "12,14,29"
# $2: separator e.g. "," (note: an empty separator string means "assign only a single value to the list")
# $3, $4, ...: variables
sa_assign_list() {
    local __sa_list="$1"
    local __sa_separator="$2"
    local __sa_i
    shift 2

    local __sa_variable
    for __sa_variable in "$@"
    do
        declare -ag "${__sa_variable}" || { ERROR "Invalid variable name: '${__sa_variable}'"; return 2; }
        log FINEST "Assigning list: ${__sa_variable}='${__sa_list}'${sa_transform_value:+ (transform: ${sa_transform_value})}"
        IFS="${__sa_separator}" read -ra "${__sa_variable}" <<< "${__sa_list}"
        if [ "${sa_transform_value}" = "envsubst" ]
        then
            declare -n __sa_tmp_array="${__sa_variable}"
            for __sa_i in ${!__sa_tmp_array[@]}
            do
                __sa_tmp_array[${__sa_i}]="$(envsubst <<< "${__sa_tmp_array[${__sa_i}]}")"
            done
        elif [ "${sa_transform_value}" = "eval" ]
        then
            declare -n __sa_tmp_array="${__sa_variable}"
            for __sa_i in ${!__sa_tmp_array[@]}
            do
                __sa_tmp_array[${__sa_i}]="$(eval "${__sa_tmp_array[${__sa_i}]}")"
            done
        fi
    done
}

# $1: list (12,14,29) or single value (12)
# $2: separator (,) or "" if single value is provided
# $3, $4, ...: variables
#
# Append three integers (1, 2 and 3) to two arrays
# > sa_append_to_list 1,2,3 , array_one array_two
# Append one string "1,2,3" to two arrays
# > sa_append_to_list 1,2,3 "" array_one array_two
sa_append_to_list() {
    local __sa_list="$1"
    local __sa_separator="$2"
    shift 2

    local __sa_variable
    local __sa_tmp_array
    for __sa_variable in "$@"
    do
        declare -ag "${__sa_variable}" || { ERROR "Invalid variable name: '${__sa_variable}'"; return 2; }
        declare -n __sa_listref="${__sa_variable}"
        log FINEST "Appending to list: ${__sa_variable}+='${__sa_list}'"
        if [ -n "${__sa_separator}" ]
        then
            IFS="${__sa_separator}" read -ra __sa_tmp_array <<< "${__sa_list}"
        else
            __sa_tmp_array=( "${__sa_list}" )
        fi

        local __sa_i
        if [ "${sa_transform_value}" = "envsubst" ]
        then
            for __sa_i in ${!__sa_tmp_array[@]}
            do
                __sa_tmp_array[${__sa_i}]="$(envsubst <<< "${__sa_tmp_array[${__sa_i}]}")"
            done
        elif [ "${sa_transform_value}" = "eval" ]
        then
            for __sa_i in ${!__sa_tmp_array[@]}
            do
                __sa_tmp_array[${__sa_i}]="$(eval "${__sa_tmp_array[${__sa_i}]}")"
            done
        fi

        __sa_listref+=( "${__sa_tmp_array[@]}" )
    done
}

# Replace <token> in <input> with <value> (print result in stdout).
# NOTE that the token should not contain sed regular expressions.
sa_replace_token() {
    local input="$1"; shift
    if [ $(( $# % 2 )) -ne 0 ]
    then
        echo "Usage: $FUNCNAME <input> <token> <value> [<token> <value>]..." >&2
        return 1
    fi
    declare -a sed_expressions=()
    while [ $# -gt 0 ]
    do
        local token="$1"
        local value="$2"
        local delimiter="$(sa_safe_delimiter "${token}" "${value}")"
        sed_expressions+=( "-e s${delimiter}${token}${delimiter}${value}${delimiter}g" )
        shift 2
    done

    if [ ${#sed_expressions[*]} -gt 0 ]
    then
        sed "${sed_expressions[@]}" <<< "${input}"
    else
        printf "%s" "${input}"
    fi
}

# Variables accepted as options for formatting
# - sa_prefix (default: "")
# - sa_suffix (default: "\n")
# - sa_delim (default: ", ")
# - sa_last_delim (default: "${sa_delim}")
# - sa_enclose (default: "")
# - sa_enclose_pre (default: "${sa_enclose}")
# - sa_enclose_post (default: "${sa_enclose}")
# - sa_ellipsis (default: ",...")
# - sa_ellipsis_suffix (default: "${sa_suffix}")
# ...for limiting the number of items printed
# - sa_max_items (default: "-1")
# - sa_max_length (default: "-1"), (approximate) maximun length of items to print in characters.
#   This includes characters that enclose the items and characters used in delimiters.
#   The prefix and suffix texts are excluded.
#
# For example,
# > sa_prefix="Numbers: " sa_delim=", " sa_last_delim=" and " sa_suffix="." sa_concatenate 1 2 3
# Numbers: 1, 2 and 3.
# > sa_concatenate 1 2 3
# 1, 2, 3
# > sa_enclose="'" sa_concatenate 1 2 3
# '1', '2', '3'
# > sa_max_items=2 sa_concatenate 1 2 3
# 1, 2,...
sa_concatenate() {
    # The names 'item' and 'token' separate the bare items (e.g. 'first item')
    # and the token to be printed (e.g. '\'first item\' ') respectively.
    # In other words, the token includes the enclosing and delimiter characters.
    local items_printed=0 total_items=$# item token
    local sa_delim="${sa_delim-, }"
    local sa_last_delim="${sa_last_delim-${sa_delim}}"
    local sa_suffix="${sa_suffix-\n}"
    local sa_enclose_pre="${sa_enclose_pre-${sa_enclose}}"
    local sa_enclose_post="${sa_enclose_post-${sa_enclose}}"

    local sa_max_items="${sa_max_items:--1}"
    local sa_max_length="${sa_max_length:--1}"
    local sa_ellipsis="${sa_ellipsis-,...}"
    local sa_ellipsis_suffix="${sa_ellipsis_suffix-${sa_suffix}}"

    #log_vars WARN total_items sa_prefix sa_suffix sa_delim sa_last_delim sa_enclose sa_enclose_pre sa_enclose_post sa_max_items sa_max_length sa_ellipsis sa_ellipsis_suffix >&2

    printf "${sa_prefix}"
    local chars_printed=0
    for item in "$@"
    do
        # Stop when when maximum number of items is reached.
        [ "${sa_max_items}" -ge 0 ] && [ "${items_printed}" -eq "${sa_max_items}" ] && break

        if [ "${items_printed}" -eq 0 ]
        then
            # First item: print the item only (and the enclosing characters)
            token="$(printf "%s%s%s" "${sa_enclose_pre}" "${item}" "${sa_enclose_post}")"
        elif [ "${items_printed}" -eq $((total_items - 1)) ]
        then
            # Last item: print the last delimiter and the item (and the enclosing characters)
            token="$(printf "%s%s%s%s" "${sa_last_delim}" "${sa_enclose_pre}" "${item}" "${sa_enclose_post}")"
        else
            # Other items: print the (normal) delimiter and the item (and the enclosing characters)
            token="$(printf "%s%s%s%s" "${sa_delim}" "${sa_enclose_pre}" "${item}" "${sa_enclose_post}")"
        fi

        # Print the token if the total length remains within the maximum. Stop otherwise.
        if [ "${sa_max_length}" -lt 0 ] || [ $(( chars_printed + ${#token} )) -le "${sa_max_length}" ]
        then
            printf "%s" "${token}"
            (( chars_printed += ${#token} ))
            (( items_printed++ ))
        else
            break
        fi
    done

    if [ "${items_printed}" -eq "${total_items}" ]
    then
        # Print the normal suffix only if all the items are printed.
        printf "${sa_suffix}"
    else
        # Don't print the ellipsis if no items are printed.
        [ "${items_printed}" -gt 0 ] && printf "${sa_ellipsis}"
        # Print "an ellipsis suffix". This is by default the same as the "normal suffix"
        # but can be customized.
        printf "${sa_ellipsis_suffix}"
    fi
}

#----- simpleargs-parsing -----#
#!/usr/bin/env bash
# simpleargs-parsing

sa_parse_endofoptions() { true; }

sa_parse_argplaceholder() {
    local token="${1}"
    if [[ "${token}" = *,* ]]; then
        # Valid values: low,medium,high
        log FINER "Interpreting argument placeholder as a comma separated list of valid values"
        sa_parse_validvalues "${token}"
    elif [[ "${token}" =~ "*"|"?"|"["|"]" ]]
    then
        # Glob: '*.txt'
        log FINER "Interpreting argument placeholder as a glob (validation)"
        sa_add_validation "glob" "${token}"
        # Notice that "not glob" has to be provided using @@!glob '*.txt'
    elif [[ "${token}" =~ ^[a-zA-Z_][a-zA-Z0-9_]*$ ]]
    then
        # Variable name: port
        log FINER "Interpreting argument placeholder as a variable name"
        sa_parse_varname "${token}"
    else
        log ERROR "Option argument token '${token}' could not be interpreted as"
        log ERROR " - comma separated list of valid argument values"
        log ERROR " - glob filter containing globbing characters *, ?, [, or ]"
        log ERROR " - valid variable name (matching [a-zA-Z_][a-zA-Z0-9_]*)"
        return "${SA_PARSE_INVALID_ARGUMENTS}"
    fi
}

sa_parse_varparam() { sa_parse_param "$@"; }
sa_parse_optionalparam() { sa_parse_param "$@"; }
sa_parse_varoptionalparam() { sa_parse_param "$@"; }
sa_parse_param() {
    local param_string="$1"
    sa_init_clientry
    clientry[entrytype]=parameter
    clientry[fullname]="${param_string}"
    clientry[on]=false

    # Convert illegal characters (probably mostly spaces and dashes) into underscores)
    # 'varname' is possibly overwritten at a later stage
    if [[ "${clientry[fullname]}" = "<"*">" ]]
    then
        # <input file>
        clientry[type]=param
        clientry[optional]=false
        clientry[varargs]=false
        clientry[varname]=$(sed -r 's/[^a-zA-Z0-9]/_/g' <<<"${clientry[fullname]:1:-1}")
    elif [[ "${clientry[fullname]}" = "[<"*">]" ]]
    then
        # [<log file>]
        clientry[type]=optionalparam
        clientry[optional]=true
        clientry[varargs]=false
        clientry[varname]=$(sed -r 's/[^a-zA-Z0-9]/_/g' <<<"${clientry[fullname]:2:-2}")
    elif [[ "${clientry[fullname]}" = "<"*">..." ]]
    then
        # <input file>...
        clientry[type]=varparam
        clientry[optional]=false
        clientry[varargs]=true
        clientry[varname]=$(sed -r 's/[^a-zA-Z0-9]/_/g' <<<"${clientry[fullname]:1:-4}")
    elif [[ "${clientry[fullname]}" = "[<"*">]..." ]]
    then
        # [<input file>]...
        clientry[type]=varoptionalparam
        clientry[optional]=true
        clientry[varargs]=true
        clientry[varname]=$(sed -r 's/[^a-zA-Z0-9]/_/g' <<<"${clientry[fullname]:2:-5}")
    fi

    clientry[id]="_${clientry[varname]}_${sa_param_counter}"
    clientry[validationarraynames]=""
    (( sa_param_counter++ ))
    clientry[docarray]="sa_docs${clientry[id]}"
    sa_params+=("${clientry[fullname]}")
}

sa_parse_option() {
    plus_indent
    local retcode=0

    local flag_def_string="$token"
    log FINER "Parsing option: '${flag_def_string}'"

    sa_init_clientry
    clientry[fullname]="${flag_def_string}" # e.g. "-p/--port"
    clientry[on]=false # Set to 'true' if given as an option.
    clientry[entrytype]=option
    # Options start as 'novalue' type: subsequent tokens can change the type
    clientry[type]=novalue
    clientry[getopt_type]=""
    clientry[rep]=0 # How many times the option is given (repetition).
    clientry[flags]="${flag_def_string//// }" # Replace every '/' with ' ' --> e.g. "-p --port"
    # Remove slashes, convert dashes to underscores: e.g. "-p/--port" --> "_p__port"
    clientry[id]="$(sed -e 's/-/_/g' -e 's|/||g' <<< "$flag_def_string")"
    clientry[mapname]="sa_option${clientry[id]}"
    clientry[validationarraynames]=""
    clientry[docarray]="sa_docs${clientry[id]}"

    log_vars_in_map FINER clientry fullname id flags mapname validationarray
    sa_record_option_definition "${clientry[fullname]}" || return

    minus_indent
}

# Records the existence of the option to global data models. The data models
# can be used to...
# - ...check that options are not define multiple times
# - ...convert between identifiers, e.g. "-b/--baudrate" --> "_b__baudrate"
sa_record_option_definition() {
    local retcode=0
    local fullname="$1"
    local mapname=${clientry[mapname]}

    local flag
    for flag in ${clientry[flags]}
    do
        # Validate and record flags
        #               -p                  --ssh-port-2
        if grep -qE -e '^-[a-zA-Z0-9]$' -e '^--[a-zA-Z0-9-]{2,}$' <<< "${flag}"
        then
            if sa_array_contains sa_flags "$flag"
            then
                log ERROR "${fullname}: Option already defined: '$flag'"
                if [ "${flag}" = "-h" ] || [ "${flag}" = "--help" ]
                then
                    # Since the help option is defined within the library provide
                    # a more reasonable error message if the user accidentally
                    # defines their own option with the same flag(s).
                    log ERROR "To disable the default help option (-h/--help) use 'sa_default_tokens=()'"
                fi
                retcode=2
            else
                sa_flags+=("$flag")
                sa_fullnames+=(["$flag"]="$fullname")
                sa_mapnames+=(["$flag"]="$mapname")
            fi
        else
            log ERROR "Invalid flag definition: '$flag'"
            retcode=2
        fi
    done

    # If options has more than one flag (usually two) add mapname mapping
    # for fullname as well (since it differs from other flag names).
    if [ "${#cliflags[@]}" -gt 1 ]
    then
        sa_mapnames+=(["$fullname"]="$mapname")
    fi

    # Record this option in global data structures
    sa_options+=("$fullname")
    sa_optionmaps+=("$mapname")
    return $retcode
}

sa_add_docs() {
    local doc_entry
    for doc_entry in "$@"
    do
        log FINER "Adding doc entry: '${doc_entry}'"
        docs+=("${doc_entry}")
    done
}

# 1.2.2022 It is evident that the current implementation allows specifying
# many validations in one token: @@file,exists,readable. Or with a different
# separator character: @@:/file:exists:readable. Furthermore, validation
# negation can be done using modifier "negate" in addition to the more
# natural '!" mark. So, @@negate/exists is the same as @@!exists
#
# However, I've forgotten these features and haven't missed them. Specifying
# @@file @@readable OR @@!file have been perfectly adequate. So, should
# the implementation be simplified as well? Not necessarily but I think
# these features shouldn't at least be documented.
#
# The current state is more than satisfactory in a sense that the usage
# of the validation directives is simple and effective. Note that using
# separate validation tokens isn't even longer to write. The two inputs
# shown below have the same validation rules.
#     "<input1>" @@:/exists:file:!glob "*.txt"
#     "<input2>" @@exists @@file @@!glob "*.txt"
sa_parse_validation() {
    plus_indent

    # @@:/negate/file:glob  $1
    #   :/negate/file:glob  $token
    #            file:glob  $token_value
    #   :/negate/           $modifier_string
    local token=${1:2}
    local token_value=${token##*/}
    local modifier_string=${token%/${value}}
    IFS="/" read -ra sa_directive_modifiers <<< "${modifier_string}"

    log_vars FINER "#Parsing validation token" token token_value modifier_string sa_directive_modifiers

    local separator=, # Default separator
    for modifier in "${sa_directive_modifiers[@]}"
    do
        if [ "${#modifier}" -eq 1 ]
        then
            separator="${modifier}"
            log "FINEST" "Using custom separator: '${separator}'"
        fi
    done

    local validation_entries
    IFS="${separator}" read -ra validation_entries <<<"${token_value}"
    log_vars FINER validation_entries
    local validation_entry  i=0
    for validation_entry in "${validation_entries[@]}"
    do
        if [ ${i} -lt $(( ${#validation_entries[*]} - 1 )) ]
        then
            # First entries are added immediately. Note that sa_add_validation
            # reads also values from sa_directive_modifiers array.
            sa_add_validation ${validation_entry}
        else
            # The last entry is left pending for further arguments
            # (added by sa_finalize_validation_command (called by sa_parse)
            read -ra sa_validation_command_words <<< "${validation_entry}"
        fi
        ((i++))
    done
    minus_indent
}

sa_parse_validationargument() {
    sa_validation_command_words+=( "${token}" )
}

# Takes one or more parameters -> one validation rule
# Note that this function takes "input parameters" also as global variables.
# That is, sa_directive_modifiers array is checked for e.g. value "negate"
# TODO: check that the validation command exists
sa_add_validation() {
    plus_indent
    local negate=$(sa_array_contains sa_directive_modifiers "negate" && echo true || echo false)
    log FINER "$(sa_prefix="Adding validation entry: " sa_delim=" " sa_enclose="'" sa_concatenate "$@")"
    declare sa_validation_command=( "$@" )
    ${negate} && log FINER "Validation command is negated (using directive modifier)"

    # Check for negate marker ('!') since the marker has to be removed if there.
    if [ "${sa_validation_command[0]:0:1}" = "!" ]
    then
        log FINER "Validation command is negated (using '!' character)"
        negate=true
        sa_validation_command[0]="${sa_validation_command[0]:1}"
    fi

    local validation_array_name=sa_validation${clientry[id]}_${sa_validation_command_index}
    sa_array_copy sa_validation_command ${validation_array_name}
    (( sa_validation_command_index++ ))
    sa_validation_command_modifiers[${validation_array_name}_negate]=${negate}
    clientry[validationarraynames]="${clientry[validationarraynames]} ${validation_array_name}"
    minus_indent
}

sa_parse_directive() {
    plus_indent

    local modifier

    # @validvalues:=local:dev:prod  $1
    #  validvalues:=local:dev:prod  token
    #  validvalues:                 directive_spec
    #  validvalues                  directive_name
    #             :                 modifier
    #               local:dev:prod  directive_value

    local token="${1:1}" # @multivalue: @default%=one,1%two,2 @validvalues+=A,B+C,D
    local directive_spec=${token%%=*} # Remove the first '=' character and everything after
    # This one is the tricky one
    case "${directive_spec:0:-1}" in
        multivalue|validvalues|default)
            modifier="${directive_spec: -1:1}"
            directive_name="${directive_spec:0:-1}"
            ;;
        *)
            modifier=""
            directive_name="${directive_spec}"
            ;;
    esac
    local directive_value=
    [[ ${token} = *=* ]] && directive_value="${token#*=}"
    log_vars FINER token directive_spec directive_name directive_value modifier
    # TODO: test what happens with @validvalues==a=b=c (hmm, there's only one valid value: '=a=b=c')
    # TODO: test what happens with @validvalues::=a:b:c (invalid directive @validvalues:)

    case "${directive_name}" in
        afterprocessing|allowrepeat|multivalue|onvalue|offvalue|optionalvalue|required)
            if [ "${clientry[entrytype]}" = "parameter" ]
            then
                log ERROR "${clientry[fullname]}: @${directive_name} is only applicable for options"
                return "${SA_PARSE_INVALID_ARGUMENTS}"
            fi
            ;;
    esac

    case "$directive_name" in
        afterprocessing)
            # TODO: Not yet implemented for parameters (will it ever be implemented?)
             clientry[afterprocessing]="${directive_value:-true}"
            ;;
        allowempty)
            clientry[allowempty]=true
            ;;
        allowrepeat)
             clientry[allowrepeat]=true
            ;;
        default)
            clientry[default]="$directive_value"
            if [ -z "${clientry[default]}" ]
            then
                log ERROR "${clientry[fullname]}: default value cannot be null (empty)"
                return "${SA_PARSE_INVALID_ARGUMENTS}"
            fi

            # TODO: add "multidefault"
            if [ -n "${modifier}" ]
            then
                :
                # Check that this is either @multivalue option, varargs or optional varargs parameter
                # clientry[defaultseparator]="${modifier}"
                # TODO: add handling to default assignment
            fi
            ;;
        doc)
            sa_add_docs "$directive_value"
            ;;
        multivalue)
            clientry[multivalue]=true
            if [ -n "${modifier}" ]
            then
                clientry[list]=true
                clientry[listseparator]="${modifier}"
                log FINEST "Recording multivalue with separator '${clientry[listseparator]}'"
            fi
            ;;
        offvalue)
            clientry[offvalue]="$directive_value"
            clientry[explicitonoffvalues]=true
            ;;
        onvalue)
            clientry[onvalue]="$directive_value"
            clientry[explicitonoffvalues]=true
            ;;
        optionalvalue)
            clientry[optionalvalue]=true
            ;;
        required)
            clientry[required]=true
            ;;
        validvaluesfile)
            clientry[validvaluesfile]="${directive_value}"
            ;;
        validvaluescommand)
            clientry[validvaluescommand]="${directive_value}"
            ;;
        validvalues)
            local separator=, # Default separator
            [ -n "${modifier}" ] && separator="${modifier}"
            # Handle parsing in the subfunction
            sa_parse_validvalues "$separator" "$directive_value"
            ;;
        varname)
            sa_parse_varname "$directive_value" false || return
            ;;
        *)
            log ERROR "Unknown directive: '@${directive_name}'"
            log ERROR "Modifiers placed after the directive name are allowed only for"
            log ERROR "@multivalue and @validvalues (e.g. @validvalues:=a,b:c,d:e,f)"
            return "${SA_PARSE_INVALID_ARGUMENTS}"
            ;;
    esac
    minus_indent
}

# 1.2.2022 This is the one that we need to simplify. The syntax for directives
# should be
#   @<name>[[,][=<value>]]
# where comma ',' is a placeholder for any character (other than '=') to be used
# as a separator character for @validvalues, @multivalue and @default (not yet
# implemented).
sa_parse_directive_old() {
    plus_indent

    local modifier

    # @/@/multivalue=hello  $1
    #  /@/multivalue=hello  token
    #  /@/multivalue        directive_spec
    #     multivalue        directive_name
    #                hello  directive_value
    #   @                   modifier_string

    local token="${1:1}" # @:/multivalue @jou/default=mydefault @hei/,/myname=myvalue
    local directive_spec=${token%%=*} # Modifiers and name
    local directive_name=${directive_spec##*/}
    local directive_value=
    [[ ${token} = *=* ]] && directive_value="${token#*=}"
    local modifier_string=
    [[ ${directive_spec} = */* ]] && modifier_string=${directive_spec%/*}
    [ "${modifier_string:0:1}" = "/" ] && modifier_string="${modifier_string:1}"
    IFS=/ read -r -a modifiers <<< "${modifier_string}"
    local one_char_modifier=""

    # Make modifiers available globally (for validation command finalization)
    declare -ag sa_directive_modifiers=( "${modifiers[@]}" )
    for modifier in "${sa_directive_modifiers[@]}"
    do
        if [ -z "${modifier}" ]
        then
            log ERROR "${clientry[fullname]} '${token}': modifier cannot be empty"
            return "${SA_PARSE_INVALID_ARGUMENTS}"
        elif [ ${#modifier} -eq 1 ]
        then
            log FINER "Recorded one character modifier: '${one_char_modifier}'"
            one_char_modifier="${modifier}"
        fi
    done
    unset modifier
    log_vars FINER token directive_spec directive_name directive_value modifier_string sa_directive_modifiers one_char_modifier

    case "$directive_name" in
        afterprocessing)
            clientry[afterprocessing]="${directive_value:-true}"
            if [ "${clientry[entrytype]}" = "parameter" ]
            then
                # TODO: not yet implemented for parameters
                log ERROR "${clientry[fullname]}: @${directive_name} is only applicable for options"
                return "${SA_PARSE_INVALID_ARGUMENTS}"
            fi
            ;;
        allowempty)
            clientry[allowempty]=true
            ;;
        allowrepeat)
            clientry[allowrepeat]=true
            ;;
        default)
            clientry[default]="$directive_value"
            if [ -z "${clientry[default]}" ]
            then
                log ERROR "${clientry[fullname]}: default value cannot be null (empty)"
                return "${SA_PARSE_INVALID_ARGUMENTS}"
            fi
            ;;
        doc)
            sa_add_docs "$directive_value"
            ;;
        multivalue)
            if [ "${clientry[entrytype]}" = "parameter" ]
            then
                log ERROR "${clientry[fullname]}: @${directive_name} is only applicable for options"
                return "${SA_PARSE_INVALID_ARGUMENTS}"
            fi

            clientry[multivalue]=true
            if [ -n "${one_char_modifier}" ]
            then
                clientry[list]=true
                clientry[listseparator]="${one_char_modifier}"
                log FINEST "Recording multivalue with separator '${clientry[listseparator]}'"
            fi
            ;;
        offvalue)
            clientry[offvalue]="$directive_value"
            clientry[explicitonoffvalues]=true
            ;;
        onvalue)
            clientry[onvalue]="$directive_value"
            clientry[explicitonoffvalues]=true
            ;;
        optionalvalue)
            clientry[optionalvalue]=true
            ;;
        required)
            if [ "${clientry[entrytype]}" = "parameter" ]
            then
                log ERROR "${clientry[fullname]}: @${directive_name} is only applicable for options"
                return "${SA_PARSE_INVALID_ARGUMENTS}"
            fi

            clientry[required]=true
            ;;
        validvaluesfile)
            clientry[validvaluesfile]="${directive_value}"
            ;;
        validvaluescommand)
            clientry[validvaluescommand]="${directive_value}"
            ;;
        validvalues)
            local separator=,
            [ -n "${one_char_modifier}" ] && separator="${one_char_modifier}"
            # Handle parsing in the subfunction
            sa_parse_validvalues "$separator" "$directive_value"
            ;;
        varname)
            sa_parse_varname "$directive_value" false || return
            ;;
        *)
            log ERROR "Unknown directive: '@${directive_name}'"
            log ERROR "For modifiers use e.g. @:/multivalue"
            return "${SA_PARSE_INVALID_ARGUMENTS}"
            ;;
    esac
    minus_indent
}

# -n/--name jack,john,james
# -n/--name name @valid=jack,john,james
# -n/--name name @valid%=jack%john%james
# -n/--name name @valid=@file:/path/to/file
# -n/--name name @valid=@command:generatenames
# -n/--name name log.txt,log.out,debug.out [file,exists]

# Usage
# > sa_parse_validvalues "<comma separated list>"
# OR
# > sa_parse_validvalues <delimiter> <delimiter separated list>"
sa_parse_validvalues() {
    local delimiter=,
    if [ $# -eq 2 ]
    then
        delimiter="$1"; shift
    fi
    values="$1"

    local arrayname=sa_valid_values${clientry[id]}
    clientry[validvaluesarray]=$arrayname

    log FINER "Creating valid values array '$arrayname'; delimiter: '$delimiter', values: '$values'"
    local tmparray
    IFS="$delimiter" read -ra tmparray <<<"$values"
    sa_array_copy tmparray $arrayname
    declare -n array=$arrayname

    local default_token="@default"
    local index value
    for index in "${!array[@]}"
    do
        value="${array[$index]}"
        if [[ "$value" = *"${default_token}" ]]
        then
            array[$index]="${value:0:-${#default_token}}"
            clientry[default]="${array[$index]}"
        fi
    done
}

# Implicit variable name: sa_parse "$0" --port http_port
# Explicit variable name: sa_parse "$0" --port ... @varname=http_port
# usage: sa_parse_varname <varname> [false]
sa_parse_varname() {
    local varname="$1"
    local implicit="${2:-true}"
    local placeholder_varname="arg"

    if [ "${clientry[entrytype]}" = option ]
    then
        if ${implicit}
        then
            clientry[type]=value; clientry[getopt_type]=":"
            if [ "${varname}" = "${placeholder_varname}" ]
            then
                log FINER "Not setting implicit variable name '${placeholder_varname}' (interpreted as a mere placeholder)"
            else
                log FINER "Setting implicit variable name: '${varname}'"
                clientry[implicit_varname]="${varname}"
            fi
        else
            log FINER "Setting explicit variable name: '${varname}'"
            clientry[explicit_varname]="${varname}"
        fi
    else # [ "${clientry[entrytype]}" = parameter ]
        log FINER "Setting parameter variable name: '${varname}'"
        clientry[varname]="${varname}"
    fi

    return 0
}

#----- simpleargs-process -----#
#!/usr/bin/env bash
# simpleargs-process

######### NOTE! ############
# Care has to be taken with variable naming and conventions in the functions below that assign
# global variables. The variable assignments that are made as a result of the user script
# invocation might overwrite variables that are used internally by simpleargs functions.
# For example, calling
#   > my-script --mapname foobar
# results in 'mapname' being (globally) assigned value "foobar". If 'mapname' is a variable
# used internally by the processing function its value is replaced which will lead to hard-to-debug
# errors. If the function does not do global variable assignments it's enough to declare
# the internally used variables local (which one should normally do anyways not to litter
# the environment). Note that simpleargs-common-util contains a set of helper functions for
# assigning values to variables for which this note is also applicable.

declare -a __sa_processing_queue=()

sa_process() {
    sa_tic_time $FUNCNAME

    log CONFIG "---------- Processing arguments ----------"
    # Declare variable on its own: 'local __sa_tmpargs=$(...)' will make the return code always 0
    local tmpargs
    tmpargs=$(getopt --options "${sa_getopt_short_options}" --longoptions "${sa_getopt_long_options}" -- "$@" 2>/dev/null)
    local getopt_result=$?
    if [ $getopt_result -ne 0 ]
    then
        local getopt_error_message=$(getopt --options "${sa_getopt_short_options}" --longoptions "${sa_getopt_long_options}" -- "$@" 2>&1 1>/dev/null)
        log ERROR "Processing arguments failed: ${getopt_error_message#getopt: }"
        return "${SA_PROCESS_GETOPT_FAILED}"
    fi
    log_vars FINE tmpargs

    # Set rest parameters and handle them.
    local tmp_leftover_args
    eval "tmp_leftover_args=( ${tmpargs} )"
    declare -ag __sa_processing_queue=( "${__sa_processing_queue[@]}" "${tmp_leftover_args[@]}" )
    #log_vars ERROR __sa_processing_queue tmp_leftover_args tmpargs
    unset tmp_leftover_args

    local __sa_mapname
    # Unset variables that are possibly set (and exported) upon script invocation
    for __sa_mapname in "${sa_optionmaps[@]}" "${sa_parammaps[@]}"
    do
        declare -n current_entry="${__sa_mapname}"
        [ ${current_entry[entrytype]} = "option" ] && unset -v ${current_entry[flagvars]}
        [ ${current_entry[entrytype]} = "parameter" ] && unset -v ${current_entry[varname]}
    done

    log_vars FINEST __sa_processing_queue
    # Check whether there are any options
    plus_indent
    while true
    do
        local __sa_flag="${__sa_processing_queue[0]}"
        log FINER "- arg: '${__sa_flag}'"
        # End of options
        [ "$__sa_flag" = "--" ] && { unset __sa_processing_queue[0]; __sa_processing_queue=( "${__sa_processing_queue[@]}" ); break; }

        log FINEST "Loading option map: '${sa_mapnames[${__sa_flag}]}'"
        declare -n __sa_option=${sa_mapnames[${__sa_flag}]}
        [ -n "${__sa_option[entrytype]}" ] || { log ERROR "Problem loading map for flag '${__sa_flag}'"; return "$SA_PROCESS_INTERNAL_ERROR"; }
        #log_vars_in_map FINEST ${sa_mapnames[${__sa_flag}]}

        __sa_option[on]=true
        __sa_option[flaggiven]="${__sa_flag}" # Distinguish between the user using '-p' and '--port'
        # Option repetition count, e.g. '-v' -> verbose, '-vv' -> more verbose
        ((__sa_option[rep]++))
        if [ "${__sa_option[allowrepeat]}" = true ]
        then
            local __sa_flagvar
            for __sa_flagvar in ${__sa_option[flagvars]}
            do
                log FINER "Assigning option repetition count: ${__sa_flagvar}_count=${__sa_option[rep]}"
                sa_assign "${__sa_option[rep]}" ${__sa_flagvar}_count || return "${SA_PROCESS_INTERNAL_ERROR}"
            done
        fi

        case ${__sa_option[type]} in
            novalue) # getopt type '' (empty)
                # Deduce the value to be assigned
                local __sa_value
                if [ "${__sa_option[explicitonoffvalues]}" = "true" ]
                then
                    # An empty string if @onvalue has not been specified
                    __sa_value="${__sa_option[onvalue]}"
                else
                    __sa_value=true # Default value for novalue options (onvalue and offvalue are null)
                fi
                sa_assign "${__sa_value}" ${__sa_option[flagvars]} || return "${SA_PROCESS_INTERNAL_ERROR}"

                unset __sa_processing_queue[0]
                __sa_processing_queue=( "${__sa_processing_queue[@]}" )
                ;;
            value) # getopt type ':'
                local __sa_value="${__sa_processing_queue[1]}"
                sa_assign "${__sa_value}" ${__sa_option[flagvars]} || return "${SA_PROCESS_INTERNAL_ERROR}"

                unset __sa_processing_queue[0] __sa_processing_queue[1]
                __sa_processing_queue=( "${__sa_processing_queue[@]}" )
                ;;
            optionalvalue) # getopt type '::'
                local __sa_value="${__sa_processing_queue[1]}"
                # NOTE! An empty value cannot be distinguished from no value provided at all.
                # That is, providing an empty value will leave the variable undefined.
                true && { sa_assign "${__sa_value}" ${__sa_option[flagvars]} || return "${SA_PROCESS_INTERNAL_ERROR}"; }

                unset __sa_processing_queue[0] __sa_processing_queue[1]
                __sa_processing_queue=( "${__sa_processing_queue[@]}" )
                ;;
            multivalue) # getopt type ':'
                local __sa_value="${__sa_processing_queue[1]}"
                sa_append_to_list "${__sa_value}" "${__sa_option[listseparator]}" ${__sa_option[flagvars]} || return "${SA_PROCESS_INTERNAL_ERROR}"

                unset __sa_processing_queue[0] __sa_processing_queue[1]
                __sa_processing_queue=( "${__sa_processing_queue[@]}" )
                ;;
#            *)
#                # Should never be reached ('sa_finalize_option' sets the option type)
#                log ERROR "Unknown option type: '${__sa_option[type]}' (${__sa_flag})"
#                return 2
#                ;;
        esac

        if [ -n "${__sa_option[afterprocessing]}" ]
        then
            log FINER "Executing 'after processing' hook: '${__sa_option[afterprocessing]}'"
            eval "${__sa_option[afterprocessing]}"
            local __sa_status=$?
            if [ "${__sa_status}" -ne 0 ]
            then
                log ERROR "'afterprocessing' hook '${__sa_option[afterprocessing]}' failed (${__sa_status})"
                return "${SA_PROCESS_HOOK_FAILURE}"
            fi
        fi
    done

    # Assign actual parameters: stop when there is either no more...
    # - ...actual parameters (e.g. "data.txt")
    # - ...formal parameters (e.g. "<input file>")
    local __sa_parammap_index=0
    while [ "${__sa_parammap_index}" -lt "${#sa_parammaps[*]}" ]
    do
        declare -n __sa_param="${sa_parammaps[${__sa_parammap_index}]}"
        if [ ${#__sa_processing_queue[*]} -gt 0 ]
        then
            local __sa_param_value="${__sa_processing_queue[0]}"
            unset __sa_processing_queue[0]
            __sa_processing_queue=( "${__sa_processing_queue[@]}" )

            __sa_param[on]=true
            log FINER "Processing actual parameter '${__sa_param_value}' (formal parameter '${__sa_param[fullname]}')"
            if ${__sa_param[varargs]}
            then
                log FINEST "(Formal) parameter is of type '${__sa_param[type]}' (varargs) and thus the last one: appending value"
                sa_append_to_list "${__sa_param_value}" "" "${__sa_param[varname]}"
            else
                sa_assign "${__sa_param_value}" "${__sa_param[varname]}" || return "${SA_PROCESS_INTERNAL_ERROR}"
                (( __sa_parammap_index++ ))
                log FINEST "(Formal) parameter is of type '${__sa_param[type]}' (not varargs): moving to the next one (${__sa_parammap_index})"
            fi
        else
            log FINER "No more actual parameters: stopping parameter assignments"
            break
        fi
    done

    # If there are formal parameters left check that they
    # are optional and assign (possible) default values
    while [ "${__sa_parammap_index}" -lt "${#sa_parammaps[*]}" ]
    do
        declare -n __sa_param="${sa_parammaps[${__sa_parammap_index}]}"; ((__sa_parammap_index++))
        if ${__sa_param[on]}
        then
            log FINER "Parameter ${__sa_param[fullname]} already on (i.e. positional parameter assigned): skipping"
        elif [ "${__sa_param[optional]}" = "true" ]
        then
            if [ -n "${__sa_param[default]}" ]
            then
                if [ "${__sa_param[varargs]}" = "true" ]
                then
                    log FINER "Assigning default (varargs) parameter value: ${__sa_param[varname]}=( '${__sa_param[default]}' )"
                    sa_assign_list "${__sa_param[default]}" "" "${__sa_param[varname]}" || return "${SA_PROCESS_INTERNAL_ERROR}"
                else
                    log FINER "Assigning default parameter value: ${__sa_param[varname]}='${__sa_param[default]}'"
                    sa_assign "${__sa_param[default]}" "${__sa_param[varname]}" || return "${SA_PROCESS_INTERNAL_ERROR}"
                fi
            else
                if [ "${__sa_param[varargs]}" = "true" ]
                then
                    log FINER "(Varargs) parameter ${__sa_param[fullname]} does not have a default: creating an empty array"
                    sa_assign_list "" "" "${__sa_param[varname]}" || return "${SA_PROCESS_INTERNAL_ERROR}"
                else
                    log FINER "Parameter ${__sa_param[fullname]} does not have a default: skipping default assignment"
                fi
            fi
        else
            log ERROR "Missing required parameter ${__sa_param[fullname]}"
            return "${SA_PROCESS_INVALID_ARGUMENTS}"
        fi
    done

    sa_assign_option_defaults || return
    sa_validate_entries || return

    # Store additional parameters so that the calling script can use
    # "set -- ${sa_args}" to discard parameters consumed by simpleargs.
    sa_args=""
    local arg
    for arg in "${__sa_processing_queue[@]}"
    do
        [ "${#sa_args}" -eq 0 ] && sa_args="$(printf %q "${arg}")" || sa_args="${sa_args} $(printf %q "${arg}")"
    done
    log FINER "Additional parameters (${#__sa_processing_queue[*]}): |${sa_args}|"
    log CONFIG "Processing arguments finished successfully"
    sa_toc_time ${FUNCNAME}; [ "${sa_benchmark}" = "true" ] && sa_print_toc_time ${FUNCNAME}
    return 0
}

# Validates both options and parameters
sa_validate_entries() {
    sa_tic_time $FUNCNAME
    log FINE "Validating options and parameters"
    declare -a validation_errors=()
    plus_indent
    local mapname
    for mapname in "${sa_optionmaps[@]}" "${sa_parammaps[@]}"
    do
        declare -n current_entry="${mapname}"

        local entry_label var_name
        if [ ${current_entry[entrytype]} = "option" ]
        then
            var_name="${current_entry[flagvars]%% *}"
            entry_label="${current_entry[fullname]}"
        elif [ ${current_entry[entrytype]} = "parameter" ]
        then
            var_name="${current_entry[varname]}"
            entry_label="${current_entry[fullname]}"
        fi

        # Check for missing required options
        if [ "${current_entry[required]}" = "true" ] && [ "${current_entry[on]}" != "true" ]
        then
            validation_errors+=("required option ${entry_label} not given")
            continue
        fi

        if ${current_entry[on]} || [ -n "${current_entry[default]}" ]
        then
            if [ "${current_entry[type]}" = novalue ]
            then
                # novalue options are not validated: their default values 'true' or 'false' do not need
                # validating nor do the values defined using @onvalue and @offvalue.
                log FINER "${current_entry[entrytype]^} '${entry_label}': not validating novalue option"
                continue
            fi
            sa_validate_entry "${var_name}" "${mapname}" "${entry_label}"
            [ $? -eq "${SA_INCORRECT_USE}" ] && return "${SA_INCORRECT_USE}"
        else
            log FINER "${current_entry[entrytype]^} '${entry_label}' not given: not validating"
        fi
    done

    if [ "${#validation_errors[*]}" -gt 0 ]
    then
        local validation_error
        for validation_error in "${validation_errors[@]}"
        do
            log ERROR "${validation_error}"
        done
        sa_toc_time ${FUNCNAME}; [ "${sa_benchmark}" = "true" ] && sa_print_toc_time ${FUNCNAME}
        return "${SA_PROCESS_VALIDATION_FAILED}"
    fi

    sa_toc_time ${FUNCNAME}; [ "${sa_benchmark}" = "true" ] && sa_print_toc_time ${FUNCNAME}
    return 0
}

sa_validate_entry() {
    local var_name="$1"
    local mapname="$2"
    local entry_label="$3"

    declare -n current_entry="${mapname}"
    declare -n var_value="${var_name}"
    log FINER "${current_entry[entrytype]^} '${entry_label}': validating variable '${var_name}'..."
    log FINEST "...with value: '${var_value}'" # Output (possibly sensitive) variable value using only FINEST log level.

    # Check empty value
    if [ "${current_entry[allowempty]}" = "true" ]
    then
        # Empty values are allowed -> If empty value is found skip the rest of the validation.
        # This allows users to explicitly allow empty values without e.g. incorporating them
        # in their regexp validation.
        if [ -z "${var_value}" ]
        then
            log FINER "Empty values are allowed AND the value is empty -> skip validation"
            return 0
        fi
    elif [ "${current_entry[type]}" = "optionalvalue" ]
    then
        # Empty values are always allowed for optionalvalue options since it's a common
        # use case to provide the flag for optionalvalue option but no value.
        log FINER "Empty values are allowed for ${current_entry[type]} options -> not checking"
        if [ -z "${var_value}" ]
        then
            # TODO: revise: what if the empty value is given explicitly (by accident)
            log FINER "Empty values are allowed AND the value is empty -> skip validation"
            return 0
        fi
    else
        # Empty values are not allowed -> If empty value is found skip the rest
        # of the validation (empty values are not likely to pass other validation)
        sa_validate_empty "${entry_label}" "${var_name}" ||
            {
                log FINER "Empty values are not allowed AND the value is empty -> skip other validation (after filing the error)"
                return 0
            }
    fi

    # Save the error count before validvalues validations. With @multivalue entries there can be
    # multiple errors (one per each value). Later we need to clear those errors if the value is
    # validated also using validation directives.
    local error_count=${#validation_errors[@]}
    # Check @validvalues, @validvaluesfile, and @validvaluescommand (if exist)
    local valid_values_defined=false
    local within_valid_values=false
    if [ -n "${current_entry[validvaluesarray]}" ]
    then
        valid_values_defined=true
        sa_validate_validvalues "${entry_label}" "${current_entry[validvaluesarray]}" "${var_name}" &&
            within_valid_values=true
    fi
    if [ -n "${current_entry[validvaluesfile]}" ]
    then
        valid_values_defined=true
        sa_validate_validvaluesfile "${entry_label}" "${current_entry[validvaluesfile]}" "${var_name}" &&
            within_valid_values=true
    fi
    if [ -n "${current_entry[validvaluescommand]}" ]
    then
        valid_values_defined=true
        sa_validate_validvaluescommand "${entry_label}" "${current_entry[validvaluescommand]}" "${var_name}" &&
            within_valid_values=true
    fi

    # Check @@ validation directives (if exist)
    if [ -z "${current_entry[validationarraynames]}" ]
    then
        # No validation directives: validation result dictated by whether value is within valid values
        if ${valid_values_defined}
        then
            if ${within_valid_values}
            then
                log FINER "Entry '%s' within valid values\n" "${entry_label}"
                return 0
            else
                log FINER "Entry '%s' not within valid values\n" "${entry_label}"
                return 1
            fi
        else
            # No validation directives and no valid values directives -> the value is valid
            log FINER "Entry '%s' has no validation directives and no valid values defined\n" "${entry_label}"
            return 0
        fi
    else
        # Validation directives present
        if ${valid_values_defined} && ${within_valid_values}
        then
            # Value within valid values: no need to check validation directives
            log FINER "Entry '%s' within valid values, skipping other validation\n" "${entry_label}"
            return 0
        else
            log FINER "Entry '%s' not within valid values: checking other validation\n" "${entry_label}"
            if ${valid_values_defined}
            then
                # Clear the validation error inserted by sa_validate_validvalues[file|command]
                while [ "${#validation_errors[@]}" -gt "${error_count}" ]
                do
                    unset validation_errors[${#validation_errors[@]}-1]
                done
            fi
            sa_validate_validationarray "${var_name}" "${mapname}" "${entry_label}"
            return
        fi
    fi
    # Unreachable: return in every branch of the if-else above.
}

sa_validate_empty() {
    local return_value=0
    local entry="$1" # Option: flag given, Parameter: fullname
    local var_name="$2"
    declare -n var_value="${var_name}"
    log FINEST "${entry}: Validating for empty values"
    local given_value
    # Note, "${var_value[@]}" works for arrays (expands to all values in the array)
    # AND ordinary variables (expands to the single value)
    plus_indent
    for given_value in "${var_value[@]}"
    do
        log FINEST "Validating for empty value: '${given_value}'"
        if [ -z "${given_value}" ]
        then
            log FINEST "Value empty: adding error"
            validation_errors+=("${entry}: value is empty (use @allowempty to allow empty values)")
            return_value=1
        fi
    done
    minus_indent
    return "${return_value}"
}

sa_validate_validationarray() {
    local var_name="$1"
    local mapname="$2"
    local entry_label="$3"

    declare -n current_entry="${mapname}"
    declare -n var_value="${var_name}"

    if [ -n "${current_entry[validationarraynames]}" ]
    then
        log FINER "Validating against validation array: '${entry_label}'"
        local validation_array_name
        for validation_array_name in ${current_entry[validationarraynames]}
        do
            sa_validate_command "${entry_label}" "${validation_array_name}" "${var_name}" "${sa_validation_command_modifiers[${validation_array_name}_negate]}"
            local result=$?
            if [ "${result}" -eq "${SA_INCORRECT_USE}" ]
            then
                return "${SA_INCORRECT_USE}"
            elif [ "${result}" -ne 0 ] && [ "${_sa_short_circuit_validation}" = "true" ]
            then
                # Provide "short circuit" option to stop at the first failure. This can be
                # used to speed up auto completion (which doesn't care about the other errors).
                return ${result}
            fi
        done
    fi
}

sa_validate_command() {
    local return_value=0
    local entry="$1" # Option: flag given, Parameter: fullname
    local command_array_name="$2"
    local var_name="$3"
    local negate="$4" # 'true' or 'false'
    declare -n var_value="${var_name}"

    # Use sa_validate_${command[0]} if it exists: e.g. 'int' -> call 'sa_validate_int'
    declare -n command=${command_array_name}
    type "sa_validate_${command[0]}" >/dev/null 2>&1 && command[0]="sa_validate_${command[0]}"
    log FINER "${entry}: Validating '${command_array_name}' (negate: ${negate})"
    log_vars FINER ${command_array_name}

    plus_indent
    local given_value
    # Note, "${var_value[@]}" works for arrays (expands to all values in the array)
    # AND ordinary variables (expands to the single value)
    for given_value in "${var_value[@]}"
    do
        log FINEST "Validating value: '${given_value}'"

        if type "${command[0]}" >/dev/null 2>&1
        then
            "${command[@]}" "${given_value}"
            local validation_result=$?
            if [ "${validation_result}" -eq "${SA_INCORRECT_USE}" ]
            then
                log FINEST "Validation command (${command[0]}) returned ${SA_INCORRECT_USE} (incorrect usage)"
                validation_errors=( "Incorrect usage of validation function: '${command[0]}'" )
                return "${SA_INCORRECT_USE}"
            fi

            ${negate} && validation_result=$( [ ${validation_result} -eq 0 ] && echo 1 || echo 0)

            if [ ${validation_result} -ne 0 ]
            then
                if [ "${_sa_dummy_validation_error_messages}" = "true" ]
                then
                    # Speed up execution when the error message is not needed
                    # (for other than signaling a validation failure).
                    validation_errors+=( "dummy error" )
                else
                    log FINEST "Validation failed (${validation_result})"
                    local error_msg_generation_status
                    unset sa_error_msg
                    if ${negate}
                    then
                        sa_gen_negated_error_msg=true "${command[@]}" "${given_value}"
                        error_msg_generation_status=$?
                    else
                        sa_gen_normal_error_msg=true "${command[@]}" "${given_value}"
                        error_msg_generation_status=$?
                    fi

                    if [ "${error_msg_generation_status}" -eq "${SA_GENERATED_ERROR_MSG_STATUS}" ]
                    then
                        log FINEST "Using custom error message: '${sa_error_msg}'"
                        validation_errors+=("${entry}: ${sa_error_msg}")
                    else
                        log FINEST "Using standard error message"
                        validation_errors+=("${entry}: value '${given_value}' failed validation for $($negate && printf "(not) ")'${command[*]}'")
                    fi
                fi
                return_value=1
            fi
        else
            validation_errors+=("${entry}: No such validation command: '${command}'")
            return_value=1
            break
        fi
    done
    minus_indent
    return "${return_value}"
}

sa_validate_validvalues() {
    local return_value=0
    local entry="$1" # Option: flag given, Parameter: fullname
    local validvalues_array_name="$2"
    local var_name="$3"
    declare -n var_value="${var_name}"
    log FINEST "${entry}: Validating against valid values"
    local given_value
    # Note, "${var_value[@]}" works for arrays (expands to all values in the array)
    # AND ordinary variables (expands to the single value)
    for given_value in "${var_value[@]}"
    do
        log FINEST "Validating value: '${given_value}'"
        if sa_transform_arrayvalue=envsubst sa_array_contains "${current_entry[validvaluesarray]}" "${given_value}"
        then
            true
        else
            declare -n validvalues_array="${current_entry[validvaluesarray]}"
            local validvalues_string="$(sa_suffix="." sa_ellipsis_suffix="" sa_last_delim=" and " sa_enclose="'" sa_max_items="${sa_print_max_valid_values}" sa_max_length="${sa_print_max_valid_values_length}" sa_concatenate "${validvalues_array[@]}")"
            validation_errors+=("${entry}: invalid value '${given_value}'"$'\n'"Valid values are: ${validvalues_string}")
            return_value=1
        fi
    done
    return "${return_value}"
}

sa_validate_validvaluesfile() {
    local return_value=0
    local entry="$1" # Option: flag given, Parameter: fullname
    local validvalues_file_def="$2" # May contain environment variables or other constructs that need evaluation
    local var_name="$3"
    declare -n var_value="${var_name}"

    local validvalues_file=$(envsubst <<< "${validvalues_file_def}")
    if [ -r "${validvalues_file}" ]
    then
        log FINE "${entry}: Validating against valid values, file: '${validvalues_file}'"
    else
        validation_errors+=("${entry}: no such \"valid values file\" (or not readable) '${validvalues_file}'")
        return 1
    fi

    local given_value
    mapfile -t validvalues_array < "${validvalues_file}"
    # Note, "${var_value[@]}" works for arrays (expands to all values in the array)
    # AND ordinary variables (expands to the single value)
    for given_value in "${var_value[@]}"
    do
        log FINEST "Validating value: '${given_value}'"
        if sa_transform_arrayvalue=envsubst sa_array_contains validvalues_array "${given_value}"
        then
            true
        else
            local validvalues_string="$(sa_suffix="." sa_ellipsis_suffix="" sa_last_delim=" and " sa_enclose="'" sa_max_items="${sa_print_max_valid_values}" sa_max_length="${sa_print_max_valid_values_length}" sa_concatenate "${validvalues_array[@]}")"
            validation_errors+=("${entry}: invalid value '${given_value}'"$'\n'"Valid values are: ${validvalues_string}")
            return_value=1
        fi
    done
    return "${return_value}"
}

sa_validate_validvaluescommand() {
    local return_value=0
    local entry="$1" # Option: flag given, Parameter: fullname
    local validvalues_command="$2"
    local var_name="$3"
    declare -n var_value="${var_name}"

    if eval "${validvalues_command}" >/dev/null 2>&1
    then
        log FINE "${entry}: Validating against valid values, command: '${validvalues_command}'"
    else
        validation_errors+=("${entry}: error executing \"valid values command\" '${validvalues_command}'")
        return 1
    fi

    local given_value
    mapfile -t validvalues_array < <(eval "${validvalues_command}")
    # Note, "${var_value[@]}" works for arrays (expands to all values in the array)
    # AND ordinary variables (expands to the single value)
    for given_value in "${var_value[@]}"
    do
        log FINEST "Validating value: '${given_value}'"
        if sa_transform_arrayvalue=envsubst sa_array_contains validvalues_array "${given_value}"
        then
            true
        else
            local validvalues_string="$(sa_suffix="." sa_ellipsis_suffix="" sa_last_delim=" and " sa_enclose="'" sa_max_items="${sa_print_max_valid_values}" sa_max_length="${sa_print_max_valid_values_length}" sa_concatenate "${validvalues_array[@]}")"
            validation_errors+=("${entry}: invalid value '${given_value}'"$'\n'"Valid values are: ${validvalues_string}")
            return_value=1
        fi
    done
    return "${return_value}"
}

sa_assign_option_defaults() {
    sa_tic_time $FUNCNAME
    log FINE "Assigning option defaults"
    plus_indent
    local __sa_mapname
    for __sa_mapname in "${sa_optionmaps[@]}"
    do
        declare -n __sa_option="${__sa_mapname}"
        if [ -n "${__sa_option[default]}" ]
        then
            # A default value is defined -> provide default value as a variable
            local __sa_flagvar
            for __sa_flagvar in ${__sa_option[flagvars]}
            do
                declare -g "${__sa_flagvar}_default=${__sa_option[default]}"
            done

            if [ "${__sa_option[on]}" != "true" ]
            then
                # The option was not given -> check option type and assign
                log FINER "Assigning default: '${__sa_option[fullname]}'"

                if [ "${__sa_option[allowrepeat]}" = true ]
                then
                    local __sa_flagvar
                    for __sa_flagvar in ${__sa_option[flagvars]}
                    do
                        sa_assign 0 ${__sa_flagvar}_count || return "${SA_PROCESS_INTERNAL_ERROR}"
                    done
                fi

                local __sa_value
                case "${__sa_option[type]}" in
                    novalue)
                        # Deduce the value to be assigned
                        if [ "${__sa_option[explicitonoffvalues]}" = "true" ]
                        then
                            # An empty string if @offvalue has not been specified
                            __sa_value="${__sa_option[offvalue]}"
                        else
                            __sa_value="${__sa_option[default]}" # 'false': Default value for novalue options (onvalue and offvalue are null)
                        fi
                        sa_transform_value=envsubst sa_assign "${__sa_value}" ${__sa_option[flagvars]} || return "${SA_PROCESS_INTERNAL_ERROR}"
                        ;;
                    value|optionalvalue)
                        sa_transform_value=envsubst sa_assign "${__sa_option[default]}" ${__sa_option[flagvars]} || return "${SA_PROCESS_INTERNAL_ERROR}"
                        ;;
                    multivalue)
                        sa_transform_value=envsubst sa_assign_list "${__sa_option[default]}" "${__sa_option[listseparator]}" ${__sa_option[flagvars]} || return "${SA_PROCESS_INTERNAL_ERROR}"
                        ;;
                esac
            fi
        fi
    done
    minus_indent
    sa_toc_time ${FUNCNAME}; [ "${sa_benchmark}" = "true" ] && sa_print_toc_time ${FUNCNAME}
    return 0
}

#----- simpleargs-util -----#
#!/usr/bin/env bash
# simpleargs-util

sa_create_config_dir() {
    local dir
    for dir in "${sa_config_dir}" "${sa_cached_options_dir}" "${sa_manpage_dir}"
    do
        if [ ! -d "${dir}" ]
        then
            mkdir -p "${dir}" || { log ERROR "Cannot create directory: '${dir}'"; return 1; }
            log CONFIG "Created directory: '${dir}'"
        fi
    done
    if [ ! -d "${sa_completed_scripts_dir}" ]
       then
       log CONFIG "Creating an empty dir for the names of scripts to auto complete: '${sa_completed_scripts_dir}'"
       mkdir -p "${sa_completed_scripts_dir}" || { log ERROR "Cannot create directory: '${sa_completed_scripts_dir}'"; return 1; }
    fi
}

# Read option and parameter definitions from a cache file.
#
# Return codes
# 0: Read cached options succesfully
# 10: Cache directory does not exist
# 11: Cached options (file) does not exist
# 12: Cached options older than the script
# 20: Cached options file exists but is not readable
sa_read_from_cache() {
    local script_name="$1"
    local cached_options="${sa_cached_options_dir}/${sa_script_name}"
    log CONFIG "Trying to read cached options: '${cached_options}'"
    if [ -d "${sa_cached_options_dir}" ]
    then
        if [ -f "${cached_options}" ]
        then
            if [ -r "${cached_options}" ]
            then
                log FINEST "Comparing timestamps (script >< cache): '${sa_script_path}' >< '${cached_options}'"
                if [ "${sa_script_path}" -nt "${cached_options}" ]
                then
                    log CONFIG "Not reading cached options: older than the script"
                    return 12
                else
                    log CONFIG "Reading cached options: '${cached_options}'"
                    . "${cached_options}"
                    local return_value=$?
                    log CONFIG "Read $(wc -c < "${cached_options}") bytes from cache file"
                    return $return_value
                fi
            else
                log ERROR "Cached options exist but is not readable: '${cached_options}'"
                return 20
            fi
        else
            log CONFIG "Cached options do not exist"
            return 11
        fi
    else
        log CONFIG "Directory for cached options does not exist: '${sa_cached_options_dir}'"
        return 10
    fi
}

# Write option and parameter definitions to a cache file.
#
# Return codes
# 0: Successfully wrote the cache file
sa_write_to_cache() {
    sa_create_config_dir || return "${SA_PARSE_INTERNAL_ERROR}"

    local script_name="$1"
    # To avoid synchronization issues (when running many instantes of the same script simultaneously) write first
    # to a temporary file (prefixed with the process ID) and in the end rename (mv) to the final cache file.
    # mv is atomic in this case: https://stackoverflow.com/questions/18706419/is-a-move-operation-in-unix-atomic
    local cached_options="${sa_cached_options_dir}/${sa_script_name}"
    local temporary_cache_file="${sa_cached_options_dir}/$$-${sa_script_name}"
    log CONFIG "Writing options to temporary cache file: '${temporary_cache_file}'"
    {
        local cachevar
        for cachevar in sa_options sa_flags sa_optionmaps sa_fullnames sa_mapnames sa_params sa_parammaps sa_varnames
        do
            echo "# ${cachevar}"
            declare -p "${cachevar}" || return "${SA_PARSE_INTERNAL_ERROR}"
            echo
        done

        echo "# getopt strings"
        declare -p sa_getopt_short_options sa_getopt_long_options || return "${SA_PARSE_INTERNAL_ERROR}"
        echo "# \"completable\" flags for Bash completion"
        declare -p sa_completable_flags || return "${SA_PARSE_INTERNAL_ERROR}"
        echo

        if [ ${#sa_optionmaps[@]} -gt 0 ]
        then
            echo "# option maps"
            declare -p ${sa_optionmaps[@]} || return "${SA_PARSE_INTERNAL_ERROR}"
            echo
        fi

        if [ ${#sa_parammaps[@]} -gt 0 ]
        then
            echo "# param maps"
            declare -p ${sa_parammaps[@]} || return "${SA_PARSE_INTERNAL_ERROR}"
            echo
        fi

        echo "# validation command modifiers"
        declare -p sa_validation_command_modifiers || return "${SA_PARSE_INTERNAL_ERROR}"

        local map_name
        local validation_array_name
        echo "# option validation arrays"
        for map_name in ${sa_optionmaps[@]}
        do
            declare -n map=${map_name}
            if [ -n "${map[validationarraynames]}" ]
            then
                echo "## ${map[fullname]}"
                for validation_array_name in ${map[validationarraynames]}
                do
                    declare -p "${validation_array_name}" || return "${SA_PARSE_INTERNAL_ERROR}"
                done
            fi
        done
        echo

        echo "# param validation arrays"
        for map_name in ${sa_parammaps[@]}
        do
            declare -n map=${map_name}
            if [ -n "${map[validationarraynames]}" ]
            then
                echo "## ${map[fullname]}"
                for validation_array_name in ${map[validationarraynames]}
                do
                    declare -p "${validation_array_name}" || return "${SA_PARSE_INTERNAL_ERROR}"
                done
            fi
        done
        echo

        echo "# option doc arrays"
        for map_name in ${sa_optionmaps[@]}
        do
            declare -n map=${map_name}
            declare -n docarray=${map[docarray]}
            if [ "${#docarray[@]}" -gt 0 ]
            then
                echo "## ${map[fullname]}"
                declare -p ${map[docarray]} || return "${SA_PARSE_INTERNAL_ERROR}"
            fi
        done
        echo

        echo "# param doc arrays"
        for map_name in ${sa_parammaps[@]}
        do
            declare -n map=${map_name}
            declare -n docarray=${map[docarray]}
            if [ "${#docarray[@]}" -gt 0 ]
            then
                echo "## ${map[fullname]}"
                declare -p ${map[docarray]} || return "${SA_PARSE_INTERNAL_ERROR}"
            fi
        done
        echo

        echo "# option valid values arrays"
        for map_name in ${sa_optionmaps[@]}
        do
            declare -n map=${map_name}
            if [ -n "${map[validvaluesarray]}" ]
            then
                echo "## ${map[fullname]}"
                declare -n validvaluesarray=${map[validvaluesarray]}
                declare -p ${map[validvaluesarray]} || return "${SA_PARSE_INTERNAL_ERROR}"
            fi
        done
        echo
        echo "# param valid values arrays"
        for map_name in ${sa_parammaps[@]}
        do
            declare -n map=${map_name}
            if [ -n "${map[validvaluesarray]}" ]
            then
                echo "## ${map[fullname]}"
                declare -n validvaluesarray=${map[validvaluesarray]}
                declare -p ${map[validvaluesarray]} || return "${SA_PARSE_INTERNAL_ERROR}"
            fi
        done
        echo

        echo "# usage instructions"
        declare -p sa_synopsis_text || return "${SA_PARSE_INTERNAL_ERROR}"
        [ -n "${sa_description_text}" ] && { declare -p sa_description_text || return "${SA_PARSE_INTERNAL_ERROR}"; }
        [ -n "${sa_parameters_text}" ] && { declare -p sa_parameters_text || return "${SA_PARSE_INTERNAL_ERROR}"; }
        [ -n "${sa_options_text}" ] && { declare -p sa_options_text || return "${SA_PARSE_INTERNAL_ERROR}"; }
        echo
    } | sed 's/^declare/declare -g/' > "${temporary_cache_file}"
    local cache_writing_status="${PIPESTATUS[0]}"
    if [ "${cache_writing_status}" -ne 0 ]
    then
        log ERROR "Failed to write cache: ${cache_writing_status}"
        return "${SA_PARSE_INTERNAL_ERROR}"
    fi
    log CONFIG "Wrote $(wc -c < "${temporary_cache_file}") bytes to temporary cache file"
    mv "${temporary_cache_file}" "${cached_options}" || return
    log CONFIG "Final cache file ready: '${cached_options}'"
}

sa_generate_valid_values_string() {
    local mapname="$1"
    if [ -z "${mapname}" ]
    then
        echo "Usage: $FUNCNAME <entry map name>" >&2
        return 1
    fi
    declare -n entry="${mapname}"

    if [ -n "${entry[validvaluesarray]}" ]
    then
        declare -n validvalues="${entry[validvaluesarray]}"
    elif [ -n "${entry[validvaluesfile]}" ]
    then
        local validvaluesfile=$(envsubst <<< "${entry[validvaluesfile]}")
        mapfile -t validvalues < "${validvaluesfile}"
    elif [ -n "${entry[validvaluescommand]}" ]
    then
        local validvaluescommand="${entry[validvaluescommand]}"
        mapfile -t validvalues < <(eval "${validvaluescommand}")
    else
        return 0 # valid_values_string is left empty
    fi
    sa_enclose="'" sa_last_delim=", and " sa_concatenate "${validvalues[@]}"
}

sa_dump_options() {
    local msg_level="$1"; shift
    log_enabled "$msg_level" || return

    log_vars_in_array $msg_level sa_options
    log "$msg_level" ""
    log_vars_in_array $msg_level sa_flags
    log "$msg_level" ""
    log_vars_in_array $msg_level sa_optionmaps
    log "$msg_level" ""
    log_vars_in_map $msg_level sa_fullnames
    log "$msg_level" ""
    log_vars_in_map $msg_level sa_mapnames
    log "$msg_level" ""
}

sa_dump_option_values() {
    local msg_level="$1"; shift
    log_enabled "$msg_level" || return

    local mapname
    for mapname in "${sa_optionmaps[@]}"
    do
        local first_flagvar=true
        declare -n map=$mapname
        local flagvar
        for flagvar in ${map[flagvars]}
        do
            ${first_flagvar} || echo -n "; "
            echo -n "${flagvar}=${!flagvar}"
            first_flagvar=false
        done
        echo
    done
}

sa_dump_option_attributes() {
    local msg_level="$1"; shift
    log_enabled "$msg_level" || return

    # Dump option attribute maps
    log "$msg_level" "##### Option maps #####"
    local mapname
    for mapname in "${sa_optionmaps[@]}"
    do
        log_vars_in_map "$msg_level" "$mapname" $*
        log "$msg_level" ""
    done
}

sa_dump_valid_values() {
    local msg_level="$1"; shift
    log_enabled "$msg_level" || return

    # Dump "valid values" arrays
    log "$msg_level" "##### Valid values arrays #####"
    local mapname
    for mapname in "${sa_optionmaps[@]}" "${sa_parammaps[@]}"
    do
        declare -n map=$mapname
        if [ -n "${map[validvaluesarray]}" ]
        then
            log_vars_in_array "$msg_level" "${map[validvaluesarray]}"
            log "$msg_level" ""
        fi
    done
}

sa_dump_validation() {
    local msg_level="$1"; shift
    log_enabled "$msg_level" || return

    log "$msg_level" "##### Validation command modifiers #####"
    log_vars "$msg_level" sa_validation_command_modifiers

    # Dump "validation" arrays
    log "$msg_level" "##### Validation arrays #####"
    local mapname
    for mapname in "${sa_optionmaps[@]}"
    do
        declare -n map=$mapname
        if [ -n "${map[validationarraynames]}" ]
        then
            log_vars "$msg_level" ${map[validationarraynames]} " "
        fi
    done
}

sa_dump_params() {
    local msg_level="$1"; shift
    log_enabled "$msg_level" || return

    # Dump parameters
    log "$msg_level" "##### Parameters #####"
    log_vars_in_array $msg_level sa_params
    log "$msg_level" ""
}

sa_dump_param_attributes() {
    local msg_level="$1"; shift
    log_enabled "$msg_level" || return

    # Dump param attribute maps
    log "$msg_level" "##### Parameter maps #####"
    local mapname
    for mapname in "${sa_parammaps[@]}"
    do
        log_vars_in_map "$msg_level" "$mapname"
        log "$msg_level" ""
    done
}

sa_dump_getopt_strings() {
    local msg_level="$1"; shift
    log_enabled "$msg_level" || return
    log_vars "$msg_level" sa_getopt_short_options sa_getopt_long_options
}

sa_debug_dump() {
    local msg_level="$1"; shift
    log_enabled "$msg_level" || return

    sa_dump_options "$msg_level"
    sa_dump_option_attributes "$msg_level"
    sa_dump_valid_values "$msg_level"
    sa_dump_validation "$msg_level"
    sa_dump_params "$msg_level"
    sa_dump_param_attributes "$msg_level"
    sa_dump_getopt_strings "$msg_level"
}

#----- simpleargs-validation-functions -----#
#!/usr/bin/env bash
# simpleargs-validation-functions

sa_validate_grep() {
    if [ $# -ne 2 ]
    then
        echo "${FUNCNAME}: incorrect number ($#) of parameters (should be 2)" >&2
        return "${SA_INCORRECT_USE}"
    fi
    local pattern="$1"
    local value="$2"

    [ "${sa_gen_normal_error_msg}" = "true" ] && { sa_error_msg="'${value}' does not match regular expression '${pattern}'"; return "${SA_GENERATED_ERROR_MSG_STATUS}"; }
    [ "${sa_gen_negated_error_msg}" = "true" ] && { sa_error_msg="'${value}' matches regular expression '${pattern}'"; return "${SA_GENERATED_ERROR_MSG_STATUS}"; }

    #log FINEST "Validating value '${value}' against regexp '${pattern}'"
    grep -q -e "${pattern}" <<< "${value}"
}

sa_validate_egrep() {
    if [ $# -ne 2 ]
    then
        echo "${FUNCNAME}: incorrect number ($#) of parameters (should be 2)" >&2
        return "${SA_INCORRECT_USE}"
    fi
    local pattern="$1"
    local value="$2"

    [ "${sa_gen_normal_error_msg}" = "true" ] && { sa_error_msg="'${value}' does not match extended regular expression '${pattern}'"; return "${SA_GENERATED_ERROR_MSG_STATUS}"; }
    [ "${sa_gen_negated_error_msg}" = "true" ] && { sa_error_msg="'${value}' matches extended regular expression '${pattern}'"; return "${SA_GENERATED_ERROR_MSG_STATUS}"; }

    #log FINEST "Validating value '${value}' against extended regexp '${pattern}'"
    grep -qE -e "${pattern}" <<< "${value}"
}

sa_validate_glob() {
    if [ $# -ne 2 ]
    then
        echo "${FUNCNAME}: incorrect number ($#) of parameters (should be 2)" >&2
        return "${SA_INCORRECT_USE}"
    fi
    local extended_glob="$1"
    local filepath="$2"
    local filename="$(basename "${filepath}")"
    [ "${sa_gen_normal_error_msg}" = "true" ] && { sa_error_msg="'${filename}' does not match glob '${extended_glob}'"; return "${SA_GENERATED_ERROR_MSG_STATUS}"; }
    [ "${sa_gen_negated_error_msg}" = "true" ] && { sa_error_msg="'${filename}' matches glob '${extended_glob}'"; return "${SA_GENERATED_ERROR_MSG_STATUS}"; }

    #log FINEST "Validating value '${value}' against glob '${extended_glob}'"
    (
        LC_COLLATE=C
        [[ "${filename}" = ${extended_glob} ]]
    )
}

sa_validate_filetype() {
    if [ $# -ne 2 ]
    then
        echo "${FUNCNAME}: incorrect number ($#) of parameters (should be 2)" >&2
        return "${SA_INCORRECT_USE}"
    fi
    local filetype_string="$1"
    local filename="$2"

    local filetype="$(file --brief --dereference "${filename}" 2>/dev/null)"
    [ "${sa_gen_normal_error_msg}" = "true" ] && { sa_error_msg="'${filename}' is not of type '${filetype_string}' (but '${filetype}')"; return "${SA_GENERATED_ERROR_MSG_STATUS}"; }
    [ "${sa_gen_negated_error_msg}" = "true" ] && { sa_error_msg="'${filename}' is of type '${filetype_string}'"; return "${SA_GENERATED_ERROR_MSG_STATUS}"; }

    [[ "${filetype}" =~ ${filetype_string} ]]
}

sa_validate_exists() {
    if [ $# -ne 1 ]
    then
        echo "${FUNCNAME}: incorrect number ($#) of parameters (should be 1)" >&2
        return "${SA_INCORRECT_USE}"
    fi

    local filename="$1"
    [ "${sa_gen_normal_error_msg}" = "true" ] && { sa_error_msg="No such file: '${filename}'"; return "${SA_GENERATED_ERROR_MSG_STATUS}"; }
    [ "${sa_gen_negated_error_msg}" = "true" ] && { sa_error_msg="File exists: '${filename}'"; return "${SA_GENERATED_ERROR_MSG_STATUS}"; }
    [ -e "$1" ]
}

sa_validate_file() {
    if [ $# -ne 1 ]
    then
        echo "${FUNCNAME}: incorrect number ($#) of parameters (should be 1)" >&2
        return "${SA_INCORRECT_USE}"
    fi

    local filename="$1"
    [ "${sa_gen_normal_error_msg}" = "true" ] && { sa_error_msg="No such (ordinary) file: '${filename}'"; return "${SA_GENERATED_ERROR_MSG_STATUS}"; }
    [ "${sa_gen_negated_error_msg}" = "true" ] && { sa_error_msg="(Ordinary) file exists: '${filename}'"; return "${SA_GENERATED_ERROR_MSG_STATUS}"; }
    [ -f "$1" ]
}

sa_validate_dir() {
    if [ $# -ne 1 ]
    then
        echo "${FUNCNAME}: incorrect number ($#) of parameters (should be 1)" >&2
        return "${SA_INCORRECT_USE}"
    fi

    local filename="$1"
    [ "${sa_gen_normal_error_msg}" = "true" ] && { sa_error_msg="No such directory: '${filename}'"; return "${SA_GENERATED_ERROR_MSG_STATUS}"; }
    [ "${sa_gen_negated_error_msg}" = "true" ] && { sa_error_msg="Directory exists: '${filename}'"; return "${SA_GENERATED_ERROR_MSG_STATUS}"; }
    [ -d "$1" ]
}

sa_validate_notempty() {
    if [ $# -ne 1 ]
    then
        echo "${FUNCNAME}: incorrect number ($#) of parameters (should be 1)" >&2
        return "${SA_INCORRECT_USE}"
    fi

    local filename="$1"
    [ "${sa_gen_normal_error_msg}" = "true" ] && { sa_error_msg="No such file or not empty: '${filename}'"; return "${SA_GENERATED_ERROR_MSG_STATUS}"; }
    [ "${sa_gen_negated_error_msg}" = "true" ] && { sa_error_msg="Non-empty file exists: '${filename}'"; return "${SA_GENERATED_ERROR_MSG_STATUS}"; }
    [ -s "$1" ]
}

sa_validate_readable() {
    if [ $# -ne 1 ]
    then
        echo "${FUNCNAME}: incorrect number ($#) of parameters (should be 1)" >&2
        return "${SA_INCORRECT_USE}"
    fi

    local filename="$1"
    [ "${sa_gen_normal_error_msg}" = "true" ] && { sa_error_msg="No such file or not readable: '${filename}'"; return "${SA_GENERATED_ERROR_MSG_STATUS}"; }
    [ "${sa_gen_negated_error_msg}" = "true" ] && { sa_error_msg="Readable file exists: '${filename}'"; return "${SA_GENERATED_ERROR_MSG_STATUS}"; }
    [ -r "$1" ]
}

sa_validate_writable() {
    if [ $# -ne 1 ]
    then
        echo "${FUNCNAME}: incorrect number ($#) of parameters (should be 1)" >&2
        return "${SA_INCORRECT_USE}"
    fi

    local filename="$1"
    [ "${sa_gen_normal_error_msg}" = "true" ] && { sa_error_msg="No such file or not writable: '${filename}'"; return "${SA_GENERATED_ERROR_MSG_STATUS}"; }
    [ "${sa_gen_negated_error_msg}" = "true" ] && { sa_error_msg="Writable file exists: '${filename}'"; return "${SA_GENERATED_ERROR_MSG_STATUS}"; }
    [ -w "$1" ]
}

sa_validate_executable() {
    if [ $# -ne 1 ]
    then
        echo "${FUNCNAME}: incorrect number ($#) of parameters (should be 1)" >&2
        return "${SA_INCORRECT_USE}"
    fi

    local filename="$1"
    [ "${sa_gen_normal_error_msg}" = "true" ] && { sa_error_msg="No such file or not executable: '${filename}'"; return "${SA_GENERATED_ERROR_MSG_STATUS}"; }
    [ "${sa_gen_negated_error_msg}" = "true" ] && { sa_error_msg="Executable file exists: '${filename}'"; return "${SA_GENERATED_ERROR_MSG_STATUS}"; }
    [ -x "$1" ]
}

sa_validate_int() {
    local usage="Usage: ${FUNCNAME} [<bounds>] <int> (got: $*)
 - range: [<min>]..[<max>], lower and upper bounds (inclusive)
   e.g. '0..10' or '-10..' or '..13' ('..' is the same as omitting bounds)
 -   int: integer value (in format accepted by Bash) to be tested
   e.g. '0' or '-12' or '+3'"

    local value
    local bounds
    local status=0
    local valid_integer=true

    if [ $# -eq 1 ]
    then
        value="$1"
    elif [ $# -eq 2 ]
    then
        bounds="$1"
        value="$2"
        [[ "${bounds}" != *..* ]] && { echo "${usage}" >&2; return 2; }

        # If there is neither min nor max value make 'bounds' empty
        # to signal that the value (integer) should be checked only for validity.
        [ "${bounds}" = ".." ] && bounds=""
    else
        echo "${FUNCNAME}: incorrect number ($#) of parameters (should be 1 or 2)" >&2
        echo "${usage}" >&2
        return "${SA_INCORRECT_USE}"
    fi

    if [ "${value}" -eq "${value}" ] 2>/dev/null
    then
        true
    else
        valid_integer=false
        status=1
    fi

    if ${valid_integer} && [ -n "${bounds}" ]
    then
        local min=${bounds%%..*} # '1'
        local max=${bounds##*..} # '6'

        if { [ -z "${min}" ] || [ "${value}" -ge "${min}" ]; } &&
           { [ -z "${max}" ] || [ "${value}" -le "${max}" ]; }
        then
            status=0
        else
            status=1
        fi
    fi

    # Normal (positive) error message: either the integer was invalid or it was not in the given range
    if [ "${sa_gen_normal_error_msg}" = "true" ]
    then
        if ${valid_integer}
        then
            if [ -n "${min}" ] && [ -n "${max}" ]
            then
                sa_error_msg="Value '${value}' not in range: ${bounds}"
            else
                [ -n "${min}" ] && sa_error_msg="Value '${value}' less than ${min}"
                [ -n "${max}" ] && sa_error_msg="Value '${value}' greater than ${max}"
            fi
        else
            sa_error_msg="Invalid integer value: '${value}'"
        fi
        return "${SA_GENERATED_ERROR_MSG_STATUS}"
    fi

    # Negative error message: the ingeger was valid (and in the given range)
    if [ "${sa_gen_negated_error_msg}" = "true" ]
    then
        if [ -n "${bounds}" ]
        then
            if [ -n "${min}" ] && [ -n "${max}" ]
            then
                sa_error_msg="Value '${value}' should not be an integer in range ${bounds}"
            else
                [ -n "${min}" ] && sa_error_msg="Value '${value}' should not be greater than or equal to ${min}"
                [ -n "${max}" ] && sa_error_msg="Value '${value}' should not be less than or equal to ${max}"
            fi
        else
            sa_error_msg="Value '${value}' should not be a valid integer"
        fi
        return "${SA_GENERATED_ERROR_MSG_STATUS}"
    fi

    return "${status}"
}

sa_validate_float() {
    local usage="Usage: ${FUNCNAME} [<bounds>] <float> (got: $*)
 - range: [<min>]..[<max>], lower and upper bounds (inclusive)
   e.g. '0..10E1' or '-1.8..12.3' or '-119e-2..13' ('..' is the same as omitting bounds)
 -   float: floating point value in simple or scientific notation to be tested
   e.g. '1.3' or '-12e2' or '+3E-2'"

    local decimal_places=20
    local value original_value bounds
    local status=0
    local valid_float=true

    if [ $# -eq 1 ]
    then
        value="$1"
    elif [ $# -eq 2 ]
    then
        bounds="$1"
        value="$2"
        [[ "${bounds}" != *..* ]] && { echo "${usage}" >&2; return 2; }

        # If there is neither min nor max value make 'bounds' empty
        # to signal that the value (float) should be checked only for validity.
        [ "${bounds}" = ".." ] && bounds=""
    else
        echo "${FUNCNAME}: incorrect number ($#) of parameters (should be 1 or 2)" >&2
        echo "${usage}" >&2
        return "${SA_INCORRECT_USE}"
    fi
    original_value="${value}"

    # http://www.regular-expressions.info/floatingpoint.html
    if grep -E '^[-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?$' <<< "${value}" >/dev/null
    then
        true
    else
        valid_float=false
        status=1
    fi

    if ${valid_float} && [ -n "${bounds}" ]
    then
        local min=${bounds%%..*} # '-2.9e3'
        local max=${bounds##*..} # '+13E1'
        local original_min="${min}"
        local original_max="${max}"

        value="$(printf "%.${decimal_places}f" "${value}")"
        [ $? -eq 0 ] || { echo "${usage}" >&2; return 2; }

        # Convert value, min and max to format understood by bc
        # https://stackoverflow.com/a/12882612 (bc does not understand scientific notation)
        if [ -n "${min}" ]
        then
            if grep -E '^[-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?$' <<< "${min}" >/dev/null
            then
                min="$(printf "%.${decimal_places}f" "${min}")" || { echo "${usage}" >&2; return 2; }
                [ "$(bc <<< "${value} >= ${min}")" -eq 1 ] || status=1
            else
                echo "Malformed min value: '${min}'" >&2
                echo "${usage}" >&2; return 2
            fi
        fi
        if [ -n "${max}" ]
        then
            if grep -E '^[-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?$' <<< "${max}" >/dev/null
            then
                max="$(printf "%.${decimal_places}f" "${max}")" || { echo "${usage}" >&2; return 2; }
                [ "$(bc <<< "${value} <= ${max}")" -eq 1 ] || status=1
            else
                echo "Malformed max value: '${max}'" >&2
                echo "${usage}" >&2; return 2
            fi
        fi
    fi

    # Normal (positive) error message: either the float was invalid or it was not in the given range
    if [ "${sa_gen_normal_error_msg}" = "true" ]
    then
        if ${valid_float}
        then
            if [ -n "${min}" ] && [ -n "${max}" ]
            then
                sa_error_msg="Value '${original_value}' not in range: ${bounds}"
            else
                [ -n "${min}" ] && sa_error_msg="Value '${original_value}' less than ${original_min}"
                [ -n "${max}" ] && sa_error_msg="Value '${original_value}' greater than ${original_max}"
            fi
        else
            sa_error_msg="Invalid float value: '${original_value}'"
        fi
        return "${SA_GENERATED_ERROR_MSG_STATUS}"
    fi

    # Negative error message: the ingeger was valid (and in the given range)
    if [ "${sa_gen_negated_error_msg}" = "true" ]
    then
        if [ -n "${bounds}" ]
        then
            if [ -n "${min}" ] && [ -n "${max}" ]
            then
                sa_error_msg="Value '${original_value}' should not be a float in range ${bounds}"
            else
                [ -n "${min}" ] && sa_error_msg="Value '${original_value}' should not be greater than or equal to ${original_min}"
                [ -n "${max}" ] && sa_error_msg="Value '${original_value}' should not be less than or equal to ${original_max}"
            fi
        else
            sa_error_msg="Value '${original_value}' should not be a valid float"
        fi
        return "${SA_GENERATED_ERROR_MSG_STATUS}"
    fi

    return "${status}"
}

#----- simpleargs-manpage -----#
#!/usr/bin/env bash
# simpleargs-manpage

sa_generate_man_page() {
    sa_create_config_dir || return "${SA_PARSE_INTERNAL_ERROR}"

    local script_name="$1"
    local script_path="$2"
    local manpage_file="${sa_manpage_dir}/${script_name}.1.gz"
    if [ -f "${manpage_file}" ]
    then
        if [ "${sa_parse_only}" = "true" ]
        then
            log CONFIG "sa_parse_only=${sa_parse_only}: refreshing manual page"
        elif [ "${manpage_file}" -ot "${script_path}" ]
        then
            log CONFIG "Manual page older than the script: refreshing"
        else
            log CONFIG "Manual page up-to-date"
            return 0
        fi
    else
        log CONFIG "Manual page does not exist: creating"
    fi

    mkdir -p "${sa_tmp_dir}/troff" || return 2
    local man_section=1
    local troff_tmp="${sa_tmp_dir}/troff/${script_name}.${man_section}-$$"
    local troff_final="${script_name}.${man_section}"
    echo -n "" > "${troff_tmp}" # Use echo to make code coverage tool mark this line

    log FINER "Writing manual page (troff) into temporary file: '${troff_tmp}'"
    exec 30>&1 >> "${troff_tmp}" # FD 30 outputs to stdout, FD 1 outputs to file ${troff_tmp}
    {
        # Comment
        echo ".\\\"This man page was generated using simpleargs ($(date +%Y%m%dT%H%M%S))."

        # Title
        echo -n ".TH ${script_name^^}"
        echo -n " ${man_section}"

        # Leave date string in man pages empty. This makes unit tests easier (the man page stays
        # the same across builds). Besides, a date in an auto-generated man page adds no value.
        #echo " \"$(date '+%B %Y')\"" # For example, "October 2017"
        echo -n " \"\""

        echo -n " \"${script_name}${sa_script_version:+ ${sa_script_version}}\""
        echo -n " \"User Scripts\""
        echo

        # Name
        echo ".SH NAME"
        echo "${script_name}${sa_short_description:+ \\- ${sa_short_description}}"

        # Synopsis
        echo ".SH SYNOPSIS"
        echo ".B ${script_name}"
        echo -n '[\fIOPTION\fR]...'
        local parammap_name
        for parammap_name in ${sa_parammaps[@]}
        do
            declare -n param=${parammap_name}
            if [ "${param[optional]}" = "true" ]
            then
                echo -n " ${param[fullname]}"
            else
                echo -n " ${param[fullname]}"
            fi
        done
        echo # newline

        # Long description
        local paragraph
        if [ "${#sa_long_description[@]}" -gt 0 ]
        then
            echo ".SH DESCRIPTION"
            for paragraph in "${sa_long_description[@]}"
            do
                echo ".PP"
                echo "${paragraph}" | sed -r -e "s/@endshortdoc@//"
            done
        fi

        # Options
        if [ "${#sa_optionmaps[@]}" -gt 0 ]
        then
            echo ".SH OPTIONS"
            local optionmap_name
            for optionmap_name in ${sa_optionmaps[@]}
            do
                declare -n option=${optionmap_name}
                echo ".TP"
                local flag arg_string escaped_flag
                local first=true
                # \fB\-u ARG\fR, \fB\-\-define-user ARG\fR
                for flag in ${option[flags]}
                do
                    escaped_flag=$(sed -e 's/^--/\\-\\-/' -e 's/^-/\\-/' <<< $flag)
                    case "${option[type]}" in
                        novalue)
                            arg_string=""
                            ;;
                        value)
                            arg_string=" ARG"
                            ;;
                        optionalvalue)
                            [[ "$flag" = --* ]] && arg_string="=[ARG]" || arg_string="[ARG]"
                            ;;
                        multivalue)
                            if [ "${option[list]}" = "true" ]
                            then
                                local separator="${option[listseparator]}"
                                arg_string=" ARG1${separator}ARG2${separator}..."
                            else
                                arg_string=" ARG"
                            fi
                            ;;
                    esac

                    if ${first}
                    then
                        first=false
                    else
                        echo -n ", "
                    fi
                    echo -n "\\fB${escaped_flag}${arg_string}\\fR"
                done
                echo # newline
                declare -n docarray="${option[docarray]}"

                if [ "${#docarray[@]}" -gt 0 ]
                then
                    local flag_and_arg="${flag}${arg_string}"
                    # Man page option description text is indented with 6 spaces (6-1=5)
                    [ ${#flag_and_arg} -gt 5 ] && [ ${#flag_and_arg} -lt 10 ] && echo .br

                    local doc_entry
                    for doc_entry in "${docarray[@]}"
                    do
                        declare -a valid_values_sed_operation=()
                        if [[ "${doc_entry}" = *"@{v}"* ]]
                        then
                            local valid_values_string="$(sa_generate_valid_values_string "${optionmap_name}")" || return
                            valid_values_sed_operation+=( "@{v}" "${valid_values_string}" )
                        fi

                        sa_replace_token "${doc_entry}" "@{d}" "${option[default]}" "@endshortdoc@" "" "${valid_values_sed_operation[@]}"
                        echo
                    done
                else
                    echo # No documentation: add an empty line.
                fi
            done
        fi
    }
    exec >&30 30>&- # stdout back to screen, close FD 30

    gzip "${troff_tmp}" || { log ERROR "Failed to gzip manual page"; return 2; }
    mv "${troff_tmp}.gz" "${sa_manpage_dir}/${troff_final}.gz" || { log ERROR "Failed to move manual page: '${troff_tmp}.gz' -> '${sa_manpage_dir}'"; return 2; }
    log FINE "Manual page (troff) stored for examining in '${troff_tmp}'"
}

#----- simpleargs-usage-printout -----#
#!/usr/bin/env bash

#|---------------------------- total width -------------------------|
#  |-- entry_def_width ---||----------- paragraph width ------------|
#|-option_doc_indentation-|
#  -p ARG, --port ARG      TCP port used to connect to the server. By
#                          default '8080' is used.
#^                   |----|
#|                     ^
#|                     |
#|                     -- separation between definition and paragraph
#-- entry_indentation
#
# > sa_build_indented_entry 80 30 "  " "-p ARG, --port ARG" [<doc paragraph>...]
# > echo "The resulting entry: ${sa_indented_entry}"
sa_build_indented_entry() {
    local total_width="$1"
    local entry_def_width="$2"
    local entry_indentation="$3"
    local def_string="$4" # For example, "-p ARG, --port ARG"
    shift 4
    # The minimum number of spaces between def_string and doc paragraph.
    local min_definition_paragraph_separation=2

    sa_indented_entry=""
    log FINEST "Building doc entry (${def_string}) with $# lines."
    log_vars FINEST total_width entry_def_width entry_indentation def_string
    # Generate string with entry_def_width spaces in it
    local option_doc_indentation="${entry_indentation}$(printf "%0.1s" $(seq 1 ${entry_def_width}) | sed -r 's/[0-9]/ /g')"

    if [ "$(( ${#def_string} + min_definition_paragraph_separation ))" -gt "${entry_def_width}" ] ||
           [ -z "$1" ] # Do not print the (trailing) indentation if there is no documentation.
    then
        log FINEST "Entry's definition string too long: putting on its own line"
        sa_indented_entry="$(printf "%s%s" "${entry_indentation}" "${def_string}")"
    else
        log FINEST "Entry's definition string short: putting alongside the first doc line: '${1}'"
        sa_indented_entry="$(printf "%s%-${entry_def_width}s%s" "${entry_indentation}" "${def_string}" "$1")"
        shift
    fi

    local line
    for line in "$@" #while [ -n "$1" ]
    do
        log FINEST "Appending doc line: '${line}'"
        sa_indented_entry="${sa_indented_entry}$(printf "\n%s%s" "${option_doc_indentation}" "${line}")"
    done
}

# Folds tokens (strings) given as arguments. That is, prints the tokens on lines
# with maximum width (given as the first argument). If a token cannot fit within
# the maximum width specified the token is printed on a single line (even though
# it exceeds the maximum width).
#
# The lines can be indented by setting environment variables specifying
# the indentation string for each line. For example, calling the function with
# > sa_fold_indent_1="  " sa_fold_indent_2="    " sa_fold_indent_5="" \
#   sa_fold_tokens 20 <token>...
# prints the tokens on lines (hopefully) no more than 20 characters wide.
# The first line is indented (prefixed) with "  ", the lines 2-4 with "    " and
# the fifth line and the lines after that have no indentation (since an empty
# indentation string is specified).
#
# Environment variable 'sa_fold_separator' (a single space by default) is used
# to separate the tokens.
sa_fold_tokens() {
    local max_line_width="$1"; shift
    if [ -z "${max_line_width}" ] || [ ! "${max_line_width}" -eq "${max_line_width}" ]
    then
        echo "Usage: ${FUNCNAME} <max line width> <token>..." >&2
        return 2
    fi

    local sa_fold_separator="${sa_fold_separator:- }"
    local token cursor=0 line=1 indent_string_var indent_string
    for token in "$@"
    do
        if [ "${cursor}" -eq 0 ]
        then
            # Update indent string if defined for the current line.
            indent_string_var="sa_fold_indent_${line}"
            [ -n "${!indent_string_var+defined}" ] && indent_string="${!indent_string_var}"

            # The beginning of line: indent and print the token even if it
            # exceeds the maximum width.
            printf "%s%s" "${indent_string}" "${token}"
            (( cursor += ${#indent_string} + ${#token} ))

            # If there's no more space on the line print newline and update
            # the cursor position and line number.
            if [ ${cursor} -ge ${max_line_width} ]
            then
                echo; cursor=0; (( line++ ))
            fi
        else
            if [ $(( cursor + ${#token} + ${#sa_fold_separator} )) -gt "${max_line_width}" ]
            then
                # The line already contains text and the next token won't fit on it:
                # print newline and update the cursor position and line number.
                echo; cursor=0; (( line++ ))
                # Update indent string if defined for the current line.
                indent_string_var="sa_fold_indent_${line}"
                [ -n "${!indent_string_var+defined}" ] && indent_string="${!indent_string_var}"

                # The beginning of line: indent and print the token even if it
                # exceeds the maximum width.
                printf "%s%s" "${indent_string}" "${token}"
                (( cursor += ${#indent_string} + ${#token} ))
            else
                # The line already contains text and the next token fits on it as well:
                # print the separator string and the token.
                printf "%s%s" "${sa_fold_separator}" "${token}"
                (( cursor += ${#token} + ${#sa_fold_separator} ))
            fi
        fi
    done

    if [ "${cursor}" -ne 0 ]
    then
        # Print the final newline if not in the beginning of a line.
        echo
    fi
    return 0
}

# sa_script_name=myscript (set by sa_parse)
# sa_script_long_name="myscript (GNU myscript)"
# sa_script_version=3.4
# sa_script_build="build 1.8.0_121"
sa_display_version() {
    if [ -n "${sa_script_version}" ]
    then
        echo "${sa_script_long_name:-${sa_script_name}} ${sa_script_version}${sa_script_build:+ (${sa_script_build})}"
    else
        log ERROR "No version set. Set script version into variable 'sa_script_version'."
        return 1
    fi
}

# Function to be called by the library OR the user script when usage instructions
# should be shown to the user.
sa_display_usage() {
    sa_tic_time "${FUNCNAME}"
    log FINE "Displaying usage instructions"
    echo "${sa_synopsis_text}"
    [ -n "${sa_description_text}" ] && echo "${sa_description_text}"
    [ -n "${sa_parameters_text}" ] && echo $'\n'"${sa_parameters_text}"
    [ -n "${sa_options_text}" ] && echo $'\n'"${sa_options_text}"
    sa_toc_time ${FUNCNAME}; [ "${sa_benchmark}" = "true" ] && sa_print_toc_time ${FUNCNAME}
    return 0
}

# Function that prints the usage instructions to stdout. This function is to be
# called by the library to cache (store) the usage instructions text (to be
# displayed later by using 'sa_display_usage' function).
sa_build_usage_instructions() {
    sa_tic_time "${FUNCNAME}"
    log FINE "Building usage help"
    local flag_separator=", "
    local entry_indentation="  "
    local total_width=80 # Using $(tput cols) would require disabling cache.
    local entry_def_width=30
    local paragraph_width=$(( total_width - entry_def_width - ${#entry_indentation} ))
    log_vars FINEST flag_separator entry_indentation total_width entry_def_width paragraph_width

    if [ -n "${sa_synopsis_text}" ]
    then
        log FINER "Using custom synopsis: '${sa_synopsis_text}'"
    else
        log FINER "Building default synopsis with ${#sa_params[@]} parameters"
        # The standard prefix of synopsis
        local synopsis_start="Usage: ${sa_script_name}"
        # Generate a string of n spaces. n is the number of characters in ${synopsis_start} + 1
        # (for the space that follows ${synopsis_start} in the synopsis.
        local indent=$(printf "%0.1s" $(seq 1 $(( ${#synopsis_start} + 1)) ) | sed 's/[0-9]/ /g' )
        # Use the string of spaces to indent tokens from line 2 onwards. For example,
        # Usage: my-command [OPTION]... <input file> <output file 1> <output file 2>
        #                               [<log file>]
        sa_synopsis_text="$(sa_fold_indent_2="${indent}" sa_fold_tokens "${total_width}" "${synopsis_start}" "[OPTION]..." "${sa_params[@]}")"
    fi

    if [ "${#sa_long_description[@]}" -gt 0 ]
    then
        log FINER "Building the first paragraph of long description."
        sa_description_text="$(echo "${sa_long_description[0]}" | sed -r -e "s/@endshortdoc@.*//" | fmt --width="${total_width}")"
    else
        log FINER "Long description not specified"
    fi

    if [ "${#sa_parammaps[@]}" -gt 0 ]
    then
        log FINER "Building parameter definitions"
        sa_parameters_text="Parameters:"
        local param_name param
        for param_name in "${sa_parammaps[@]}"
        do
            declare -n param="${param_name}"
            log FINER "Building param entry for '${param[fullname]}'"
            plus_indent

            local doc_string=
            declare -n docarray="${param[docarray]}"
            unset -v doc_lines
            if [ "${#docarray[@]}" -gt 0 ]
            then
                declare -a valid_values_sed_operation=()
                if [[ "${docarray[0]}" = *"@{v}"* ]]
                then
                    log FINEST "${param_name}: doc contains '@{v}'"
                    local valid_values_string="$(sa_generate_valid_values_string "${param_name}")" || return
                    log FINEST "${param_name}: generated valid values string: '${valid_values_string}'"
                    valid_values_sed_operation+=( "@{v}" "${valid_values_string}" )
                fi

                doc_string=$(sa_replace_token "${docarray[0]}" "@{d}" "${param[default]}" "@endshortdoc@.*" "" "${valid_values_sed_operation[@]}")
                log FINEST "Created doc string: '${doc_string}'"

                mapfile -t doc_lines < <(echo "${doc_string}" | fmt --width="${paragraph_width}")
                log FINEST "Split doc string into ${#doc_lines[@]} lines."
            else
                log FINEST "Param doc array is empty, using empty doc string"
            fi

            sa_build_indented_entry "${total_width}" "${entry_def_width}" "${entry_indentation}" "${param[fullname]}" "${doc_lines[@]}"
            sa_parameters_text="${sa_parameters_text}"$'\n'"${sa_indented_entry}"
            minus_indent
        done
    fi

    if [ "${#sa_optionmaps[@]}" -gt 0 ]
    then
        log FINER "Building option definitions"
        sa_options_text="Options:"
        local option_name option
        for option_name in "${sa_optionmaps[@]}"
        do
            declare -n option="${option_name}"
            log FINER "Building option entry for '${option[fullname]}' (${option[type]})"
            plus_indent
            local flag
            local formatted_flags=()
            for flag in ${option[flags]}
            do
                if [ "${option[type]}" = "optionalvalue" ]
                then
                    if [[ "${flag}" == --* ]]
                    then
                        # Long flag: --sort
                        formatted_flags+=( "${flag}[=ARG]" )
                    else
                        # Short flag: -s
                        formatted_flags+=( "${flag}[ARG]" )
                    fi
                elif [ "${option[type]}" = "novalue" ]
                then
                    formatted_flags+=( "${flag}" )
                elif [ "${option[type]}" = "value" ]
                then
                    formatted_flags+=( "${flag} ARG" )
                elif [ "${option[type]}" = "multivalue" ]
                then
                    if [ "${option[list]}" = "true" ]
                    then
                        formatted_flags+=( "${flag} ARG1${option[listseparator]}ARG2${option[listseparator]}..." )
                    else
                        formatted_flags+=( "[${flag} ARG]..." )
                    fi
                fi
            done
            local formatted_flag_string=$(sa_delim="${flag_separator}" sa_suffix="" sa_concatenate "${formatted_flags[@]}")

            local doc_string=
            declare -n docarray="${option[docarray]}"
            unset -v doc_lines
            if [ "${#docarray[@]}" -gt 0 ]
            then
                declare -a valid_values_sed_operation=()
                if [[ "${docarray[0]}" = *"@{v}"* ]]
                then
                    log FINEST "${option_name}: doc contains '@{v}'"
                    local valid_values_string="$(sa_generate_valid_values_string "${option_name}")" || return
                    log FINEST "${option_name}: generated valid values string: '${valid_values_string}'"
                    valid_values_sed_operation+=( "@{v}" "${valid_values_string}" )
                fi

                doc_string=$(sa_replace_token "${docarray[0]}" "@{d}" "${option[default]}" "@endshortdoc@.*" "" "${valid_values_sed_operation[@]}")
                log FINEST "Created doc string: '${doc_string}'"

                mapfile -t doc_lines < <(echo "${doc_string}" | fmt --width="${paragraph_width}")
                log FINEST "Split doc string into ${#doc_lines[@]} lines."
            else
                log FINEST "Option doc array is empty, using empty doc string"
            fi

            sa_build_indented_entry "${total_width}" "${entry_def_width}" "${entry_indentation}" "${formatted_flag_string}" "${doc_lines[@]}"
            sa_options_text="${sa_options_text}"$'\n'"${sa_indented_entry}"
            minus_indent
        done
    fi
    sa_toc_time ${FUNCNAME}; [ "${sa_benchmark}" = "true" ] && sa_print_toc_time ${FUNCNAME}
    return 0
}

#----- simpleargs-install-utils -----#
#!/usr/bin/env bash

sa-install-local() {
    sa_install_precheck "${FUNCNAME}" "$@" || return
    sa_internal_install local install "$@"
}

sa-uninstall-local() {
    sa_install_precheck "${FUNCNAME}" "$@" || return
    sa_internal_install local uninstall "$@"
}

sa-install-global() {
    sa_install_precheck "${FUNCNAME}" "$@" || return
    sa_internal_install global install "$@"
}

sa-uninstall-global() {
    sa_install_precheck "${FUNCNAME}" "$@" || return
    sa_internal_install global uninstall "$@"
}

sa_install_precheck() {
    local caller_function_name="$1"
    local usage="Usage: ${caller_function_name} <simpleargs-bundle>"
    local bundle="$2"

    if [ $# -ne 2 ]
    then
        # The caller function (e.g. sa-install-local) should be called with 1 argument
        echo "ERROR: Incorrect number or arguments" >&2
        echo "${usage}" >&2
        return 1;
    fi

    if [ -z "${bundle}" ]
    then
        echo "ERROR: No bundle file provided" >&2
        echo "${usage}" >&2
        return 1;
    elif [ ! -f "${bundle}" ]
    then
        echo "ERROR: No such bundle file: '${bundle}'" >&2
        echo "${usage}" >&2
        return 1;
    elif ! grep --silent "^sa-install-global()" "${bundle}"
    then
        echo "ERROR: The provided file seems not to be simpleargs bundle: '${bundle}'" >&2
        echo "${usage}" >&2
        return 1
    else
        return 0
    fi
}

sa_internal_install() {
    local scope="$1" # "global" or "local"
    local action="$2" # "install" or "uninstall"
    local bundle="$3"
    if [ "${scope}" = "global" ]
    then
        if [ "${EUID}" -ne 0 ]
        then
            echo "ERROR: You must be root to install globally" >&2
            return 1
        fi
        local install_dir=/usr/lib/simpleargs
        local bootstrap_file=/etc/bash.bashrc
    elif [ "${scope}" = "local" ]
    then
        local install_dir="${HOME}"/.simpleargs.d
        local bootstrap_file="${HOME}"/.bashrc
    else
        echo "ERROR: unknown scope: '${scope}'" >&2
        return 1
    fi

    if [ "${action}" = "install" ]
    then
        sa_execute_install "${scope}" \
                           "${bundle}" \
                           "${install_dir}" \
                           "${bootstrap_file}"
    elif [ "${action}" = "uninstall" ]
    then
        sa_execute_uninstall "${scope}" \
                             "${bundle}" \
                             "${install_dir}" \
                             "${bootstrap_file}"
    else
        echo "ERROR: unknown action: '${action}'" >&2
        return 1
    fi
}

sa_execute_uninstall() {
    echo "Uninstalling simpleargs..."
    local install_type="$1" # "global" or "local"
    local bundle="$2"
    local install_dir="$3"
    local bootstrap_file="$4"

    echo "Deleting installation directory: '${install_dir}'"
    rm -r "${install_dir}" ||
        { echo "ERROR: cannot delete install directory: '${install_dir}'"; return 1; }

    echo "Removing bootstrap code from '${bootstrap_file}'"
    local bootstrap_start_token="# simpleargs start #"
    local bootstrap_end_token="# simpleargs end #"
    sed -i "/${bootstrap_start_token}/,/${bootstrap_end_token}/ d" "${bootstrap_file}" ||
        { echo "ERROR: cannot remove bootstrap code from '${bootstrap_file}'"; return 1; }
}

sa_execute_install() {
    echo "Installing simpleargs..."
    local install_type="$1" # "global" or "local"
    local bundle="$2"
    local install_dir="$3"
    local bootstrap_file="$4"

    local bundle_destination="${install_dir}"/simpleargs-bundle
    local rc_destination="${install_dir}"/simpleargs.rc
    local completion_lib_destination="${install_dir}"/simpleargs-completion
    local config_destination="${install_dir}"/simpleargs.conf

    if [ -d "${install_dir}" ]
    then
        echo "Installation directory already exists: '${install_dir}'"
        echo "Overwriting library (does not affect possible existing cache files)"
    else
        mkdir "${install_dir}" || { echo "ERROR: cannot create directory: '${install_dir}'" >&2; return 1; }
    fi

    # Bundle
    cp "${bundle}" "${bundle_destination}" ||
        { echo "ERROR: cannot install '${bundle_destination}'" >&2; return 1; }
    chmod 644 "${bundle_destination}" ||
        { echo "ERROR: cannot set permissions: '${bundle_destination}'" >&2; return 1; }

    # RC file
    sa-generate-rc > "${rc_destination}" ||
        { echo "ERROR: cannot create rc file: '${rc_destination}'" >&2; return 1; }
    chmod 644 "${rc_destination}" ||
        { echo "ERROR: cannot set permissions: '${rc_destination}'" >&2; return 1; }

    # Completion library
    sa-generate-completion-runtime > "${completion_lib_destination}" ||
        { echo "ERROR: cannot create completion lib: '${completion_lib_destination}'" >&2; return 1; }
    chmod 644 "${completion_lib_destination}" ||
        { echo "ERROR: cannot set permissions: '${completion_lib_destination}'" >&2; return 1; }

    # Configuration file
    echo "### ${install_type^} configuration file for simpleargs ###" > "${config_destination}"
    cat >> "${config_destination}" <<'EOF'
#
# The precedence of the configuration sources. Sources higher in the list
# take precedence.
# 1. Environment variables given on script invocation. For example,
#      > log_level=FINER myscript --user john
# 2. Variables assigned in (individual) scripts before sourcing simpleargs:
#      # Default log level if not given as an environment variable.
#      : ${log_level:=INFO}
#      . "${SIMPLEARGS}" || { echo "Error loading '${SIMPLEARGS}'" >&2; exit 1; }
# 3. User specific configuration in ~/.simpleargs.conf (if exists):
#      # Default log level for simpleargs scripts if not already specified.
#      : ${log_level:=WARN}
# 4. Global configuration in /etc/simpleargs.conf (if exists):
#      # Default (global) log level if not overridden by user configuration,
#      # the script itself or an environment variable.
#      : ${log_level:=ERROR}
# 5. Default values in simpleargs bundle: used if not defined in
#    any of the above sources.
#
# Note the syntax:
#   : ${sa_use_cache:=true}
# will set variable 'sa_use_cache' to 'true' only if it was unset before.
# This enables the precedence mechanism described above: the definition in
# sources that are lower on the list take effect only if the variable has not
# been configured by the higher precedence source. However, using
#   sa_use_cache=true
# in e.g. the global configuration will set the value to 'true' unconditionally.
# That is, trying to change the value using an environment variable or variable
# assignment in the script will have no effect since the global settings is
# read further down the chain. This behaviour might or might not be wanted.
# Usually it is good practice to only provide some global default configuration
# and let the script writer (or user) override the values.

# Disable script definition cache
# : ${sa_use_cache:=false}
EOF

    local bootstrap_start_token="# simpleargs start #"
    local bootstrap_end_token="# simpleargs end #"

    local bootstrap_tmp_file=/tmp/simpleargs-bootstrap-tmp
    cat > "${bootstrap_tmp_file}" <<EOF
${bootstrap_start_token}
# $(date)
export SIMPLEARGS_DIR="${install_dir}"
export SIMPLEARGS="\${SIMPLEARGS_DIR}/simpleargs-bundle"
. "\${SIMPLEARGS_DIR}/simpleargs.rc"
${bootstrap_end_token}
EOF
    [ $? -eq 0 ] || { echo "ERROR: cannot create temporary bootstrap file: '${bootstrap_tmp_file}'"; return 1; }

    if grep --silent "^${bootstrap_start_token}$" "${bootstrap_file}"
    then
        # TODO: should the old bootstrap code be removed?
        echo "Bootstrap code already exist in '${bootstrap_file}'"
    else
        # Append a newline to the file if it is missing
        if [ -s "${bootstrap_file}" ] && [ -n "$(tail -c 1 "${bootstrap_file}")" ]
        then
            echo >> "${bootstrap_file}"
        fi

        cat "${bootstrap_tmp_file}" >> "${bootstrap_file}"
        [ $? -eq 0 ] || { echo "ERROR: cannot insert bootstrap code into '${bootstrap_file}'"; return 1; }
    fi

    echo "Installation complete"
    echo "       User home directory: ${HOME}"
    echo "                    Bundle: ${bundle_destination}"
    echo "Utility functions + config: ${rc_destination}"
    echo "        Completion library: ${completion_lib_destination}"
    echo "        Configuration file: ${config_destination}"
    echo "     Bootstrap appended to: ${bootstrap_file}"

    . "${bootstrap_tmp_file}" || { echo "ERROR: error when sourcing temporary bootstrap file: '${bootstrap_tmp_file}'"; return 1; }
    rm "${bootstrap_tmp_file}" || { echo: "ERROR: cannot delete temporary bootstrap file: '${bootstrap_tmp_file}'"; return 1; }
}

sa-generate-rc() {
    cat <<'SA_GENERATE_RC_EOF'
#!/usr/bin/env bash

# Convenience function to check that the system has (hopefully) all the
# required utility commands available.
sa-requirements() {
    local cmd
    local cmd_status
    local exit_code=0
    for cmd in bash bc cut date envsubst eval fmt getopt grep gzip printf sed tr
    do
        cmd_status="OK"
        case "${cmd}" in
            bash)
                [ "${BASH_VERSINFO[0]}" -eq 5 ] || cmd_status="FAIL (Bash version is not 5)"
                ;;
            getopt)
                if type "${cmd}" >/dev/null 2>&1
                then
                    getopt --test >/dev/null # Check that one has the "enhanced" getopt
                    [ $? -eq 4 ] || cmd_status="FAIL (not enhanced getopt)"
                else
                    cmd_status="FAIL (not found)"
                fi
                ;;
            grep)
                if grep --version 2>/dev/null | grep -q "GNU grep"
                then
                    :
                else
                    cmd_status="FAIL (not GNU grep)"
                fi
                ;;
            date)
                if type "${cmd}" >/dev/null 2>&1
                then
                    local date_output="$(date +%s%3N)"
                    if [ "${date_output}" -ne "${date_output}" ]
                    then
                        cmd_status="FAIL (does not support field width)"
                    fi
                else
                    cmd_status="FAIL (not found)"
                fi
                ;;
            sed)
                if sed --version 2>/dev/null | grep --silent "GNU sed"
                then
                    :
                else
                    cmd_status="FAIL (not GNU sed)"
                fi
                ;;
            *)
                type "${cmd}" >/dev/null 2>&1 || cmd_status="FAIL (not found)"
                ;;
        esac
        [ "${cmd_status}" = "OK" ] || exit_code=1
        printf "%10s %s\n" "${cmd}" "${cmd_status}"
    done
    if [ "${exit_code}" -ne 0 ]
    then
        echo "ERROR: not all requirements are met"
        echo "Have you installed GNU coreutils?"
    fi
    return "${exit_code}"
}

# This function is invoked at the bottom of this file but can also be used to
# refresh the completion functionality manually (usually there's no need to).
sa-refresh-completion() {
    local simpleargs_completion="${SIMPLEARGS_DIR}/simpleargs-completion"
    if [ -r "${simpleargs_completion}" ]
    then
        . "${simpleargs_completion}" ||
            { echo "ERROR: sourcing simpleargs completion: '${simpleargs_completion}'" >&2;
              return 1; }
    else
        echo "ERROR: simpleargs completion file not found (or not readable): '${simpleargs_completion}'" >&2
        return 1
    fi

    local simpleargs_completed_scripts_dir="${SIMPLEARGS_DIR}/completed-scripts"
    if [ -d "${simpleargs_completed_scripts_dir}" ]
    then
        if ls "${simpleargs_completed_scripts_dir}"/* >/dev/null 2>&1
        then
            local script
            for script in "${simpleargs_completed_scripts_dir}"/*
            do
                complete -F _simpleargs_general_completion "${script##*/}"
            done
        fi
    else
        mkdir "${simpleargs_completed_scripts_dir}"
    fi
}

sa-clean-completion() {
    local simpleargs_completed_scripts_dir="${SIMPLEARGS_DIR}/completed-scripts"
    if ls "${simpleargs_completed_scripts_dir}"/* >/dev/null 2>&1
    then
        rmdir "${simpleargs_completed_scripts_dir}"/*
    fi
}

sa-create-script() {
    local usage="\
Usage: ${FUNCNAME} [minimal|template|verbose] <script name>
       ${FUNCNAME} -h/--help
Example: ${FUNCNAME} minimal myscript
Create a script with varying degree of example content:
 - minimal: minimal content for using simpleargs library (default)
 - template: simple example script
 - verbose: more versatile example"
    if [ "$1" = "-h" ] || [ "$1" = "--help" ]
    then
        echo "${usage}"
        return 1
    fi

    local type file
    if [ $# -eq 1 ]
    then
        type=minimal
        file="$1"
    elif [ $# -eq 2 ]
    then
        type="$1"
        file="$2"
    else
        echo "${usage}" >&2
        return 1
    fi

    [[ "${type}" =~ ^(minimal|template|verbose)$ ]] || { echo "${usage}" >&2; return 1; }
    [ -z "${file}" ] && { echo "${usage}" >&2; return 1; }
    [ -e "${file}" ] && { echo "'${file}' already exists" >&2; return 1; }
    touch "${file}" || { echo "Failed to create file: '${file}'" >&2; return 1; }
    chmod u+x "${file}" || { echo "Failed set file executable: '${file}'" >&2; return 1; }
    case "${type}" in
        minimal)
            ########## Minimal script ##########
cat <<'EOF' >> "${file}"
#!/usr/bin/env bash

# -------------------------------- simpleargs --------------------------------
. "${SIMPLEARGS}" || { echo "Error loading '${SIMPLEARGS}'" >&2; exit 1; }
sa_parse "$0"
sa_end_parse $?; sa_process "$@"; sa_end_process $?; eval "set -- ${sa_args}"
# ----------------------------------------------------------------------------
EOF
;;
        template)
            ########## Template script ##########
cat <<'EOF' >> "${file}"
#!/usr/bin/env bash

sa_short_description=""
sa_long_description=(
"Paragraph 1"
"Paragraph 2"
)

# -------------------------------- simpleargs --------------------------------
# : ${SIMPLEARGS:=$(dirname "$0")/simpleargs-bundle}
# : ${SIMPLEARGS:=/usr/lib/simpleargs/simpleargs-bundle}
. "${SIMPLEARGS}" || { echo "Error loading '${SIMPLEARGS}'" >&2; exit 1; }

sa_parse "$0" -u/--user arg -p/--port arg "<input file>"
sa_end_parse $?; sa_process "$@"; sa_end_process $?; eval "set -- ${sa_args}"
# ----------------------------------------------------------------------------

log_level=INFO
log_vars INFO user port input_file
EOF
;;
        verbose)
            ########## Verbose script ##########
sed "s|@script-basename@|$(basename "${file}")|" <<'EOF' >> "${file}"
#!/usr/bin/env bash

sa_script_long_name="ABC Inc. @script-basename@"
sa_script_version=1.0
sa_script_build="build 1"
sa_short_description="example simpleargs script"
sa_long_description=(
"Demonstrates the usage of simpleargs library."
"The second paragraph of the script description can be seen on the man page"
)
sa_default_tokens=( @expand=help @expand=version )

# -------------------------------- simpleargs --------------------------------
# : ${SIMPLEARGS:=$(dirname "$0")/simpleargs-bundle}
# : ${SIMPLEARGS:=/usr/lib/simpleargs/simpleargs-bundle}
. "${SIMPLEARGS}" || { echo "Error loading '${SIMPLEARGS}'" >&2; exit 1; }

sa_parse "$0" \
         -u/--user arg @default=root @doc="OS user to use (default: @{d})." \
         -p/--port arg @default=80 @doc="Connection port (default: @{d})." \
         "<input file>" @@glob "*.txt" @doc="Input file with .txt suffix."
sa_end_parse $?; sa_process "$@"; sa_end_process $?; eval "set -- ${sa_args}"
# ----------------------------------------------------------------------------

echo "User '${user}' connecting to port ${port} (input: ${input_file})"
EOF
;;
        *)
            echo "${usage}" >&2
            return 1
            ;;
    esac

    echo "Created script '${file}'"
    if [ -n "${SA_SCRIPT_EDITOR}" ]
    then
        ${SA_SCRIPT_EDITOR} "${file}"
    fi
}

# When ${SA_EAGER_CACHE_REFRESH} is set to "true" this function is executed
# if no completion routine has been defined for the command (for which
# the auto completion was tried). This function can then check if there is
# such completion routine available.
#
# This function first tries to figure out if the command in question is
# a simpleargs based script and if yes, it runs it with sa_parse_only=true
# "modifier" to generate the cache file and completion routine marker
# (a directory under ~/.simpleargs.d/completed-scripts). It then runs
# sa-refresh-completion to assign the simpleargs completion routine to
# this command and returns 124 to signal that the completion should be
# retried.
#
# If the command in question is not a simpleargs based script the execution
# is handed to the system's own completion loader function.
_sa_completion_loader() {
    local __sa_start=$(date +%s%3N)
    local exit_status
    local command="$1"
    local command_base_name="${command##*/}"
    _sa_tty_echo WARN $'\n\n'"------------------------- _sa_completion_loader --------------------------------"
    _sa_tty_echo INFO "          command: '${command}'"
    _sa_tty_echo INFO "command_base_name: '${command_base_name}'"

    local script_path
    if [ "${command}" = "${command_base_name}" ]
    then
        # Command in PATH is used e.g. 'ls'
        # TODO: revise (test 'which' with binaries, functions, aliases, builtins, etc.)
        # TODO: or use --skip-alias --skip-functions
        script_path=$(which "${command}" 2>/dev/null)
        if which "${command}" >/dev/null 2>&1
        then
            script_path=$(which "${command}" 2>/dev/null)
        else
            _sa_tty_echo INFO "Command '${command}' not in PATH"
        fi
    else
        # Command is used directly e.g. './process.sh'
        script_path="${command}"
    fi
    _sa_tty_echo INFO "script_path: '${script_path}'"

    if [ -f "${script_path}" ]
    then
        # TODO: this is very fragile (changing one character in the script's header breaks this)
        if grep -Fq 'sa_parse "$0"' "${script_path}" &&
           grep -Fq 'sa_end_parse $?; sa_process "$@"; sa_end_process $?; eval "set -- ${sa_args}"' "${script_path}"
        then
            _sa_tty_echo INFO "Most probably a simpleargs-based script: running parse only"
            sa_parse_only=true ${command} >/dev/null 2>&1
            if [ $? -eq 0 ]
            then
                _sa_tty_echo INFO "Success"
                sa-refresh-completion
                exit_status=124
            else
                _sa_tty_echo INFO "Failure"
                exit_status=1
            fi
        else
            _sa_tty_echo INFO "Does not seem to be a simpleargs-based script"
            exit_status=-1
        fi
    else
        exit_status=-1
    fi

    local __sa_end=$(date +%s%3N)
    _sa_tty_echo INFO "Took: $(( __sa_end - __sa_start )) ms"
    if [ "${exit_status}" -ge 0 ]
    then
        return "${exit_status}"
    else # exit_status == -1
        if [ -n "${_sa_system_completion_loader}" ]
        then
            if [ "${_sa_system_completion_loader}" = "${FUNCNAME}" ]
            then
                _sa_tty_echo INFO "Not calling '${_sa_system_completion_loader}' (avoid infinite recursion)"
            else
                _sa_tty_echo INFO "Running system completion loader: '${_sa_system_completion_loader}'"
                ${_sa_system_completion_loader} "${command}"
            fi
        else
            _sa_tty_echo INFO "No system completion loader set: returning"
        fi
    fi
}

# This is a development convenience trick. Without it there's no auto completion functionality
# for a newly created script that hasn't been run yet (one needs to run it first and then
# refresh the completion definitions by e.g. opening a new shell).
if [ "${SA_EAGER_CACHE_REFRESH}" = "true" ]
then
    # Store the original system completion loader so that we can call it
    # (if the command tried to be completed is not a simpleargs based one).
    _sa_system_completion_loader="$(complete -p -D 2>/dev/null | sed -r 's/^complete.*-F ([^ ]+).*/\1/')"
    #echo "System completion loader: '${_sa_system_completion_loader}'"
    # Replace the system completion loader with our own
    complete -D -F _sa_completion_loader -o bashdefault -o default
fi

# An easy way of including simpleargs generated man pages in MANPATH
export PATH="${PATH}:${HOME}/.simpleargs.d/bin"
# "Revert" https://bugs.launchpad.net/ubuntu/+source/npm/+bug/1211104#yui_3_10_3_1_1401988279719_290
[[ "${COMP_WORDBREAKS}" = *=* ]] || COMP_WORDBREAKS="${COMP_WORDBREAKS}="

sa-refresh-completion
SA_GENERATE_RC_EOF
}

sa-generate-completion-runtime() {
    cat <<'SA_GENERATE_COMPLETION_RUNTIME_EOF'
#!/usr/bin/env bash

#!/usr/bin/env bash
# simpleargs-constants

SA_PARSE_INVALID_ARGUMENTS=2
SA_PARSE_CANNOT_READ_CACHE=8
SA_PARSE_INTERNAL_ERROR=9
SA_PROCESS_INVALID_ARGUMENTS=2
SA_PROCESS_VALIDATION_FAILED=3
SA_PROCESS_GETOPT_FAILED=4
SA_PROCESS_HOOK_FAILURE=5
SA_PROCESS_INTERNAL_ERROR=9
SA_INTERNAL_ERROR=11
SA_INCORRECT_USE=12
SA_GENERATED_ERROR_MSG_STATUS=14
SA_USAGE_INSTRUCTIONS_EMPTY=15

#!/usr/bin/env bash

_sa_record_coverage() {
    local marker=$(printf %04d "$1")
    echo "" >> "${SA_COMPLETION_COVERAGE_DIR}/${marker}"
}

_simpleargs_general_completion() {
    #SA_COV
    __sa_start=$(date +%s%3N)
    local ind="    "

    # "Disable" logging functions present in validation functions
    log() { :; }
    log_vars() { :; }
    plus_indent() { :; }
    minus_indent() { :; }

    sa_tic_time completion
    sa_tic_time completion_state
    sa_stopwatch_reset validation

    local i map_name
    local script="$(basename "${COMP_WORDS[0]}")"
    if [ "${_sa_last_completed_script}" != "${script}" ]
    then
        #SA_COV
        _sa_tty_echo ERROR $'\n\n\n\n\n\n\n\n\n\n'
        _sa_last_completed_script="${script}"
    fi
    _sa_tty_echo WARN $'\n\n'"--------------------------------------------------------------------------------"
    _sa_tty_echo CONFIG "$(compopt)"
    _sa_tty_echo WARN "${FUNCNAME}: ${script}, ${COMP_CWORD}/$((${#COMP_WORDS[@]}-1)), ${COMP_POINT} (type: ${COMP_TYPE})"
    _sa_tty_echo WARN "$(_simpleargs_print_ruler "${COMP_POINT}")"
    _sa_tty_echo WARN "${COMP_LINE}"
    _sa_tty_echo WARN "${COMP_WORDS[@]}"

    if [ "${_sa_completion_display_all_tokens}" = "true" ]
    then
        #SA_COV
        for i in ${!COMP_WORDS[@]}
        do
            #SA_COV
            [ "${i}" -eq "${COMP_CWORD}" ] && _sa_tty_echo INFO -n "  "
            _sa_tty_echo INFO "$(printf "%2d" "${i}"): ${COMP_WORDS[${i}]}"
        done
    fi

    COMPREPLY=()
    if [ -d "${HOME}" ]
    then
        #SA_COV
        _sa_tty_echo CONFIG "Using HOME='${HOME}'"
    else
        #SA_COV
        local HOME_not_configured_msg="\$HOME ('${HOME}') not set or not a directory: auto complete disabled"
        _sa_tty_echo ERROR "${HOME_not_configured_msg}"
        echo
        echo "${HOME_not_configured_msg}"
        return
    fi
    #SA_COV

    local cache_file="${HOME}/.simpleargs.d/cached/${script}"
    if [ -r "${cache_file}" ]
    then
        #SA_COV
        # Try to keep the command completion up-to-date when developing or debugging a script.
        if [ "${SA_EAGER_CACHE_REFRESH}" = "true" ]
        then
            #SA_COV
            _sa_tty_echo INFO "Checking if cache file needs to be refreshed"
            local script_path="$(which "${script}" 2>/dev/null)"
            if [ -x "${script_path}" ]
            then
                #SA_COV
                _sa_tty_echo INFO "${ind}     script: '${script}'"
                _sa_tty_echo INFO "${ind}script_path: '${script_path}'"
                if [ "${script_path}" -nt "${cache_file}" ]
                then
                    #SA_COV
                    _sa_tty_echo INFO -n "${ind}Refreshing cache file by running ${script}..."
                    if sa_parse_only=true ${script} >/dev/null 2>/dev/null
                    then
                        #SA_COV
                        _sa_tty_echo INFO "OK"
                    else
                        #SA_COV
                        _sa_tty_echo INFO "ERROR"
                        _sa_tty_echo ERROR "$(sa_parse_only=true ${script})"
                        echo "Failed to run 'sa_parse_only=true ${script}' to refresh cache" >&2
                    fi
                else
                    #SA_COV
                    _sa_tty_echo INFO "Cache file up to date"
                fi
            else
                #SA_COV
                _sa_tty_echo INFO "Script not executable: '${script_path}'"
                echo "Cannot run 'sa_parse_only=true ${script} (path: '${script_path}') to refresh cache (not executable)" >&2
            fi
        fi

        #SA_COV
        _sa_tty_echo INFO "Sourcing cache file: '${cache_file}'"
        . "${cache_file}" || { echo "Problem sourcing cache file: ${cache_file}"; return 1; }
    else
        #SA_COV
        _sa_tty_echo ERROR "No such cache file (or not readable): '${cache_file}'"
        _sa_tty_echo ERROR "Using Bash default completion as fallback (and removing completion function if exists)"
        compopt -o default
        complete -r "${script}"

        local completed_scripts_parent_dir="${HOME}/.simpleargs.d/completed-scripts"
        local completed_script_marker_dir="${completed_scripts_parent_dir}/${script}"
        if [ -d "${completed_scripts_parent_dir}" ] && [ -d "${completed_script_marker_dir}" ]
        then
            #SA_COV
            _sa_tty_echo INFO "Removing '${script}' from completed scripts: '${completed_scripts_parent_dir}'"
            rmdir "${completed_script_marker_dir}" ||
                _sa_tty_echo ERROR "Unable to delete completed script marker dir: '${completed_script_marker_dir}'"
        else
            #SA_COV
            _sa_tty_echo WARN "Completed scripts parent dir or marker dir not found: '${completed_script_marker_dir}'"
        fi

        return 1
    fi

    #SA_COV
    # Optimize auto completion speed by skipping redundant validations and fancy error messages.
    : ${_sa_short_circuit_validation:=true}
    : ${_sa_dummy_validation_error_messages:=true}

    # Implement the auto completion by examining all the arguments using a state machine:
    local expecting=option/param
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local expected_pos_parameter=0
    local current_flag=""
    local list_separator=""

    sa_truncated_words=(${COMP_LINE:0:$COMP_POINT})
    sa_truncated_cur="${sa_truncated_words[-1]}"

    _sa_tty_echo CONFIG ""
    _sa_tty_echo CONFIG "Truncation:"
    { echo -n "${ind}"; declare -p sa_truncated_words; } | _sa_tty_echo CONFIG
    _sa_tty_echo CONFIG "${ind}          cur: '${cur}'"
    _sa_tty_echo CONFIG "${ind}truncated cur: '${sa_truncated_cur}'"

    # The word is not empty AND the word is the prefix of ${cur} AND the word does not contain spaces
    if [ "${sa_truncated_cur}" != "${cur}" ] &&
           [ -n "${sa_truncated_cur}" ] &&
           [[ "${cur}" =~ "${sa_truncated_cur}"* ]] &&
           ! [[ "${cur}" =~ .*" ".* ]]
    then
        #SA_COV
        _sa_tty_echo CONFIG "${ind}Replacing cur: '${sa_truncated_cur}'"
        _sa_tty_echo CONFIG "${ind}         (was: '${cur}')"
        cur="${sa_truncated_cur}"
    fi

    _sa_tty_echo INFO $'\n'"Iterating over tokens:"
    for i in ${!COMP_WORDS[@]}
    do
        #SA_COV
        local token="${COMP_WORDS[${i}]}"
        _sa_tty_echo INFO "$(printf "%-70s (%d)" "'${token}'" "${i}")"
        if [ "${i}" -eq 0 ]
        then
            #SA_COV
            # First item: print out the script name
            _sa_tty_echo INFO "${ind}script invocation: '${COMP_WORDS[${i}]}'"
        elif [ "${i}" -eq "${COMP_CWORD}" ]
        then
            #SA_COV
            # Last item: break out of the loop to provide the auto
            # completion options based on the current token.
            #_sa_tty_echo INFO "${ind}stopping at current token: '${token}'"
            _sa_tty_echo INFO "${ind}stopping at current token: '${cur}'"
            _sa_tty_echo INFO "${ind}expecting: ${expecting}"
            break
        elif [ "${expecting}" = "param" ]
        then
            #SA_COV
            # Flags are over (after encountering '--') --> the token
            # can be no other than a (positional) parameter.
            _sa_tty_echo INFO "${ind}param(${expected_pos_parameter}), flags over, consuming: '${token}'"
            (( expected_pos_parameter++ ))
            expecting="param"
        elif [[ "${expecting}" = *separator* ]] && [ "${token}" = "${list_separator}" ]
        then
            #SA_COV
            # If we're expecting a list separator and the next token is one there's no
            # other option than assume it is a list separator. Note that the following
            # cases are indistinguishable from each other:
            # > my --list dog:cat:   # Expecting the next animal
            # > my --list dog:cat :  # Two animals and the first pos param ':' given
            _sa_tty_echo INFO "${ind}separator (list), consuming"
            expecting="value"
        elif [[ "${expecting}" = *equals* ]] && [ "${token}" = "=" ]
        then
            #SA_COV
            # Equals sign after a long flag (mandatory or optional value)
            _sa_tty_echo INFO "${ind}consuming '='"
            expecting="value"
        elif [ "${expecting}" = "value" ] || [ "${expecting}" = "value/equals" ]
        then
            #SA_COV
            _sa_tty_echo INFO "${ind}value, consuming: '${token}'"
            map_name="${sa_mapnames[${current_flag}]}"
            declare -n option="${map_name}"
            if [ "${option[list]}" = "true" ]
            then
                #SA_COV
                if [[ "${COMP_WORDBREAKS}" = *${list_separator}* ]]
                then
                    #SA_COV
                    # List separator is one of the word break characters and will thus
                    # be processed as a separate token.
                    expecting=option/param/separator
                else
                    #SA_COV
                    # List separator are included in the (value) token.
                    expecting=option/param
                    current_flag=""
                fi
            else
                #SA_COV
                expecting=option/param
                current_flag=""
            fi
        else
            #SA_COV
            case "${token}" in
                --)
                    #SA_COV
                    current_flag=""
                    expecting="param"
                    _sa_tty_echo INFO "${ind}flags over"
                    ;;
                -[a-zA-Z0-9]*)
                    #SA_COV
                    # Loop through the characters after the '-' to handle combination of flags. For example,
                    # -vvv
                    # -vhssize (-v -h -ssize)
                    # 1. If the character is novalue flag move to the next one.
                    #    If this was the last one (maybe the only): expecting=option/param
                    # 2. If the flag takes a value: check if there is one (the following characters)
                    #  - yes: expecting=option/param
                    #  -  no: expecting=value
                    #  ...and terminate
                    # 3. If the flag takes an optional value: check if there is one (the following characters)
                    #  - yes: expecting=option/param
                    #  -  no: expecting=option/param
                    #  ...so actually there's no need to check for the value
                    # 4. If the character is an invalid (non-existing) flag terminate.
                    for (( i=1; i<${#token}; i++ ))
                    do
                        #SA_COV
                        local flag="-${token:i:1}"
                        local map_name="${sa_mapnames[${flag}]}"
                        if [ -n "${map_name}" ]
                        then
                            #SA_COV
                            declare -n option="${map_name}"
                            if [ "${option[type]}" = "novalue" ]
                            then
                                #SA_COV
                                # Novalue (short) flag: just skip to the next one
                                _sa_tty_echo INFO "${ind}option (novalue): '${flag}'"
                                expecting=option/param
                            elif [ "${option[type]}" = "value" ]
                            then
                                #SA_COV
                                # Value (short) flag: check if this is the last character of the token
                                if [ "${i}" -eq $(( ${#token} - 1 )) ]
                                then
                                    #SA_COV
                                    # Last character, for example: "command -vu jack" (verbose, user: jack)
                                    _sa_tty_echo INFO "${ind}option (next: value), terminating: '${flag}'"
                                    current_flag="${flag}"
                                    expecting=value
                                else
                                    #SA_COV
                                    # Characters follow, for example: "command -vujack" (verbose, user: jack)
                                    _sa_tty_echo INFO "${ind}option and value: '-${token:i:1} ${token:i+1}'"
                                    current_flag=""
                                    expecting=option/param
                                fi
                                break
                            elif [ "${option[type]}" = "optionalvalue" ]
                            then
                                #SA_COV
                                # Optional value (short) flag: handle the following scenarios in the same way:
                                # 1. command -stime param1 # Sort by time
                                # 2. command -s param1     # Sort by (some) default criteria e.g. name
                                # In both cases the next token is not related to the flag.
                                _sa_tty_echo INFO "${ind}option (and optional value): '-${token:i}'"
                                current_flag=""
                                expecting=option/param
                                break
                            elif [ "${option[type]}" = "multivalue" ]
                            then
                                #SA_COV
                                # List value (short) flag: handle as value flag + store the list separator
                                if [ "${i}" -eq $(( ${#token} - 1 )) ]
                                then
                                    #SA_COV
                                    # Last character, for example: "command -vd Tim+Tom" (verbose, dogs: Tim and Tom)
                                    _sa_tty_echo INFO "${ind}option (next: multivalue), terminating: '${flag}'"
                                    current_flag="${flag}"
                                    expecting=value
                                    if [ "${option[list]}" = "true" ]
                                    then
                                        #SA_COV
                                        list_separator="${option[listseparator]}"
                                    else
                                        #SA_COV
                                        list_separator=""
                                    fi
                                else
                                    #SA_COV
                                    # Characters follow, for example: "command -vdTim+Tom" (verbose, dogs: Tim and Tom)
                                    _sa_tty_echo INFO "${ind}option and list value, terminating: '-${token:i}'"
                                    current_flag=""
                                    expecting=option/param
                                fi
                                break
                            fi
                        else
                            #SA_COV
                            _sa_tty_echo INFO "${ind}ERROR: invalid (short) flag: '${flag}'"
                            expecting=option/param
                        fi
                    done
                    ;;
                --[a-zA-Z0-9]*)
                    #SA_COV
                    # Long flag might be of form --example-flag=examplevalue but '=' should be one of
                    # the word break characters and thus will be processed as a separate token.
                    local flag="${token}"
                    local map_name="${sa_mapnames[${flag}]}"
                    if [ -n "${map_name}" ]
                    then
                        #SA_COV
                        declare -n option="${map_name}"
                        if [ "${option[type]}" = "novalue" ]
                        then
                            #SA_COV
                            _sa_tty_echo INFO "${ind}long option (novalue): '${flag}'"
                            expecting=option/param
                        elif [ "${option[type]}" = "value" ]
                        then
                            #SA_COV
                            _sa_tty_echo INFO "${ind}long option (next: value/equals): '${flag}'"
                            current_flag="${flag}"
                            expecting=value/equals
                        elif [ "${option[type]}" = "optionalvalue" ]
                        then
                            #SA_COV
                            _sa_tty_echo INFO "${ind}long option (optional value): '${token}'"
                            current_flag="${flag}"
                            expecting=option/param/equals
                        elif [ "${option[type]}" = "multivalue" ]
                        then
                            #SA_COV
                            if [ "${option[list]}" = "true" ]
                            then
                                #SA_COV
                                _sa_tty_echo INFO "${ind}long option (next: list/equals), (list separator: '${option[listseparator]}'): '${flag}'"
                                list_separator="${option[listseparator]}"
                            else
                                #SA_COV
                                _sa_tty_echo INFO "${ind}long option (next: (multi)value)): '${flag}'"
                                list_separator=""
                            fi
                            current_flag="${flag}"
                            expecting=value/equals
                        fi
                    else
                        #SA_COV
                        _sa_tty_echo INFO "${ind}ERROR: invalid (long) flag: '${flag}'"
                        expecting=option/param
                    fi
                    ;;
                "=")
                    #SA_COV
                    if [[ "${expecting}" =~ *equals* ]]
                    then
                        #SA_COV
                        _sa_tty_echo INFO "${ind}equals '=', consuming"
                        expecting=value
                    else
                        #SA_COV
                        _sa_tty_echo INFO "${ind}ERROR: not expecting '='"
                        expecting=option/param
                    fi
                    ;;
                *)
                    #SA_COV
                    _sa_tty_echo INFO "${ind}param(${expected_pos_parameter}), consuming: '${token}'"
                    (( expected_pos_parameter++ ))
                    expecting="option/param"
                    ;;
            esac
        fi
        #SA_COV
        _sa_tty_echo INFO "${ind}expecting: ${expecting}"
    done
    sa_toc_time completion_state

    #SA_COV
    # Previous command line tokens processed: generate the auto completion
    # values based on the current token and the state of the command line
    # as indicated by the state machine.
    sa_tic_time completion_operation
    _sa_tty_echo INFO -n $'\n'"OPERATION: "
    case "${expecting}" in
        option/param|option/param/equals|option/param/separator)
            #SA_COV
            if [ "${expecting}" = "option/param/equals" ] && [ "${cur}" = "=" ]
            then
                #SA_COV
                # command --sort=<tab>
                _sa_tty_echo INFO "return option values for '${current_flag}' (after '=')"
                _simpleargs_complete_value "${sa_mapnames[${current_flag}]}" "" ""
                compopt -o filenames
            elif [ "${expecting}" = "option/param/separator" ] && [ "${cur}" = "${list_separator}" ]
            then
                #SA_COV
                # command --cats Garfield:
                _sa_tty_echo INFO "return all the list options (after '${list_separator}')"
                _simpleargs_complete_value "${sa_mapnames[${current_flag}]}" "" ""
                compopt -o filenames
            else
                #SA_COV
                if [[ "${cur}" = --* ]] || [ "${cur}" = "-" ]
                then
                    #SA_COV
                    # --sor<tab> OR -<tab>
                    COMPREPLY=( $(compgen -W "${sa_completable_flags}" -- "${cur}" ) )
                    _sa_tty_echo INFO "return completable flags"
                    compopt -o filenames
                elif [[ "${cur}" = -* ]]
                then
                    #SA_COV
                    # command -u user -vts<tab>
                    _sa_tty_echo INFO "loop through characters to see what to return"
                    for (( i=1; i<${#cur}; i++ ))
                    do
                        #SA_COV
                        local flag="-${token:i:1}"
                        _sa_tty_echo INFO -n "${ind}${flag}: "
                        local map_name="${sa_mapnames[${flag}]}"
                        if [ -n "${map_name}" ]
                        then
                            #SA_COV
                            declare -n option="${map_name}"
                            if [ "${option[type]}" = "novalue" ]
                            then
                                #SA_COV
                                _sa_tty_echo INFO "novalue flag (iterate forward)"
                            elif [ "${option[type]}" = "value" ]
                            then
                                #SA_COV
                                _sa_tty_echo INFO "value flag"
                                local value="${cur:i+1}"
                                break
                            elif [ "${option[type]}" = "optionalvalue" ]
                            then
                                #SA_COV
                                _sa_tty_echo INFO "optional value flag"
                                local value="${cur:i+1}"
                                break
                            elif [ "${option[type]}" = "multivalue" ]
                            then
                                #SA_COV
                                _sa_tty_echo INFO "multivalue flag"
                                local value="${cur:i+1}"
                                break
                            fi
                        else
                            #SA_COV
                            _sa_tty_echo INFO "ERROR, invalid flag"
                        fi
                    done

                    # Handle the actual completion generation
                    if [ -n "${map_name}" ]
                    then
                        #SA_COV
                        if [ "${option[type]}" = "novalue" ]
                        then
                            #SA_COV
                            _sa_tty_echo INFO "${ind}Last flag is of type ${option[type]}: appending space"
                            COMPREPLY=( "${cur}" ) # Complete by appending a space
                        elif [ "${option[type]}" = "optionalvalue" ] || [ -n "${value}" ]
                        then
                            #SA_COV
                            _sa_tty_echo INFO "${ind}Last flag type: '${option[type]}' (value: '${value}'): return values"
                            _simpleargs_complete_value "${map_name}" "${cur:0:i+1}" "${value}"
                            compopt -o filenames
                        else
                            #SA_COV
                            _sa_tty_echo INFO "${ind}Last flag type: '${option[type]}' (value: '${value}'): appending space"
                            COMPREPLY=( "${cur}" ) # Complete by appending a space
                        fi
                    else
                        #SA_COV
                        # Falls back to expecting option/param which might
                        # or might not be what the user expects or wants.
                        _sa_tty_echo INFO "${ind}ERROR: Last flag is invalid"
                    fi
                else
                    #SA_COV
                    # command -u user input.tx<tab>
                    _sa_tty_echo INFO "return param(${expected_pos_parameter})"
                    _simpleargs_complete_param "${expected_pos_parameter}" "${cur}"
                fi
            fi
            ;;
        param)
            #SA_COV
            # command -u user -- input1.txt <tab>
            _sa_tty_echo INFO "return param(${expected_pos_parameter}) (expecting only param)"
            _simpleargs_complete_param "${expected_pos_parameter}" "${cur}"
            ;;
        value|value/equals)
            #SA_COV
            if [ "${expecting}" = "value/equals" ] && [ "${cur}" = "=" ]
            then
                #SA_COV
                # command --baudrate=<tab>
                _sa_tty_echo INFO "return option values for '${current_flag}' (after '=')"
                _simpleargs_complete_value "${sa_mapnames[${current_flag}]}" "" ""
                compopt -o filenames
            else
                #SA_COV
                # command -u <tab>
                # command --baudrate <tab>
                # command --cats Elmer:<tab>
                # command --dogs Jack,<tab>

                declare -n option="${sa_mapnames[${current_flag}]}"
                if [ "${option[type]}" = "multivalue" ]
                then
                    #SA_COV
                    if [ "${option[list]}" = "true" ]
                    then
                        #SA_COV
                        if [[ "${COMP_WORDBREAKS}" = *${option[listseparator]}* ]]
                        then
                            #SA_COV
                            # List separator is in COMP_WORDBREAKS
                            _sa_tty_echo INFO "list: return option values for '${current_flag}'"
                            _simpleargs_complete_value "${sa_mapnames[${current_flag}]}" "" "${cur}"
                        else
                            #SA_COV
                            # List separator is NOT in COMP_WORDBREAKS: the completion value
                            # must be prepended by the token value up to (and including)
                            # the list separator.
                            _sa_tty_echo INFO "list: return option values for '${current_flag}' (separator: '${option[listseparator]}')"

                            # Split token into prefix and suffix
                            # Token       |Prefix       |Suffix
                            # ----------------------------------
                            # ad          |             |ad
                            # add         |             |add
                            # add,        |add,         |
                            # add,remo    |add,         |remo
                            # add,remove, |add,remove,  |
                            local prefix="" suffix=""
                            for (( i=0; i <${#token}; i++ ))
                            do
                                #SA_COV
                                suffix="${suffix}${token:i:1}"
                                if [ "${token:i:1}" = "${option[listseparator]}" ]
                                then
                                    #SA_COV
                                    prefix="${prefix}${suffix}"
                                    suffix=""
                                fi
                            done
                            _simpleargs_complete_value "${sa_mapnames[${current_flag}]}" "${prefix}" "${suffix}"
                        fi
                        if [ ${#COMPREPLY[@]} -eq 1 ]
                        then
                            #SA_COV
                            _sa_tty_echo INFO "${ind}only one completion ('${COMPREPLY[0]}'): adding completion+separator"
                            COMPREPLY[1]="${COMPREPLY[0]}${list_separator}"
                        fi
                        #SA_COV
                        _sa_tty_echo INFO "${ind}list value: not appending space"
                        compopt -o nospace
                    else
                        #SA_COV
                        _sa_tty_echo INFO "${ind}multivalue (not list): return option values for '${current_flag}'"
                        _simpleargs_complete_value "${sa_mapnames[${current_flag}]}" "" "${cur}"
                    fi
                else
                    #SA_COV
                    _sa_tty_echo INFO "single value: return option values for '${current_flag}'"
                    _simpleargs_complete_value "${sa_mapnames[${current_flag}]}" "" "${cur}"
                fi
            fi
            ;;
        *)
            #SA_COV
            _sa_tty_echo INFO "ERROR: unknown state, expecting: '${expecting}'"
            ;;
    esac
    sa_toc_time completion_operation

    #SA_COV
    _sa_tty_echo CONFIG "$(compopt)"
    _sa_tty_echo FINER -n "COMPREPLY: "
    for i in ${!COMPREPLY[@]}
    do
        #SA_COV
        _sa_tty_echo FINER -n "[${i}]='${COMPREPLY[${i}]}' "
    done
    _sa_tty_echo FINER ""

    if [ "${_sa_completion_benchmark}" = "true" ]
    then
        #SA_COV
        _sa_tty_echo INFO "$(sa_toc_and_print completion)"
        _sa_tty_echo INFO "${ind}$(sa_print_toc_time completion_state)"
        _sa_tty_echo INFO "${ind}$(sa_print_toc_time completion_operation)"
        _sa_tty_echo INFO "${ind}${ind}$(sa_print_toc_time completion_filter_candidates)"
    fi
    __sa_end=$(date +%s%3N)
    _sa_tty_echo INFO "Took: $(( __sa_end - __sa_start )) ms"
    # The same figure can be echoed to current terminal (I don't remember what this is used for.)
    [ "${_sa_echo_overall_benchmark}" = "true" ] && echo "Took: $(( __sa_end - __sa_start )) ms"

    # Clear variables that were set when the cache file was sourced.
    # Note that the variables that should not be cleared should start e.g. with '_sa_'
    unset -v ${!sa_*}
    return 0
}

_simpleargs_complete_param() {
    local expected_pos_parameter="$1"
    local current_value="${2}"

    #SA_COV
    # Check which parameter (if any) are we trying to complete and then
    # delegate to _simpleargs_complete_value
    if [ "${#sa_parammaps[@]}" -eq 0 ]
    then
        #SA_COV
        _sa_tty_echo INFO "${ind}no parameters defined: use Bash default completion"
        compopt -o default # Fallback completion
    elif [ "${expected_pos_parameter}" -lt "${#sa_parammaps[@]}" ]
    then
        #SA_COV
        local map_name="${sa_parammaps[${expected_pos_parameter}]}"
        declare -n param="${map_name}"
        _sa_tty_echo INFO "${ind}parameter definition available (${param[fullname]}): return param(${expected_pos_parameter})"
        _simpleargs_complete_value "${map_name}" "" "${current_value}"
    else
        #SA_COV
        local last_map_name="${sa_parammaps[-1]}"
        declare -n last_param="${last_map_name}"

        if [[ "${last_param[fullname]}" = *... ]]
        then
            #SA_COV
            _sa_tty_echo INFO "out of parameters, the last parameter '${last_param[fullname]}' is varargs"
            _simpleargs_complete_value "${last_map_name}" "" "${current_value}"
        else
            #SA_COV
            _sa_tty_echo INFO "${ind}out of formal parameters"
            compopt -o bashdefault # Fallback completion
        fi
    fi
    return 0
}

_simpleargs_complete_value() {
    #SA_COV
    local mapname="${1}"
    local prefix="${2}"
    local current_value="${3}"

    # For example
    #   > command -vvupostgr
    # would produce the following invocation arguments
    #   mapname=sa_option_u__user
    #   current_value=postgr
    #   prefix=-vvu

    declare -n entry="${mapname}"
    local compgen_string i

    _sa_tty_echo CONFIG "${ind}Analyzing completions for ${entry[entrytype]} '${entry[fullname]}'"
    _sa_tty_echo CONFIG "${ind}${ind}current_value: '${current_value}'"
    _sa_tty_echo CONFIG "${ind}${ind}prefix: '${prefix}'"
    if [ -n "${entry[validvaluesarray]}" ] ||
           [ -n "${entry[validvaluesfile]}" ] ||
           [ -n "${entry[validvaluescommand]}" ]
    then
        #SA_COV
        if [ -n "${entry[validvaluesarray]}" ]
        then
            #SA_COV
            declare -n validvalues="${entry[validvaluesarray]}"
        elif [ -n "${entry[validvaluesfile]}" ]
        then
            #SA_COV
            local validvaluesfile=$(envsubst <<< "${entry[validvaluesfile]}")
            _sa_tty_echo CONFIG "${ind}${ind}validvaluesfile: '${validvaluesfile}'"
            mapfile -t validvalues < "${validvaluesfile}"
        elif [ -n "${entry[validvaluescommand]}" ]
        then
            #SA_COV
            local validvaluescommand="${entry[validvaluescommand]}"
            _sa_tty_echo CONFIG "${ind}${ind}validvaluescommand: '${validvaluescommand}'"
            mapfile -t validvalues < <(eval "${validvaluescommand}")
        fi

        if [ -n "${prefix}" ]
        then
            #SA_COV
            _sa_tty_echo CONFIG "${ind}${ind}prepending prefix: '${prefix}'"
            for i in ${!validvalues[@]}
            do
                #SA_COV
                validvalues[${i}]="${prefix}${validvalues[${i}]}"
            done
        fi

        if [ ${#validvalues[@]} -eq 0 ]
        then
            #SA_COV
            compgen_string=""
        else
            #SA_COV
            compgen_string="$(printf "%q " "${validvalues[@]}")"
            compgen_string="${compgen_string:0:-1}" # Strip off the trailing space character
        fi
        #SA_COV
        _sa_tty_echo CONFIG "${ind}${ind}valid values string: '${compgen_string}'"
        mapfile -t COMPREPLY < <( compgen -W "${compgen_string}" -- "${prefix}${current_value}" )

        # By default don't consider the valid values to be filenames. This deals with the problem
        # when we have a valid value like 'dev' AND our current working directory contains
        # a directory named 'dev', in which case the autocomplete would erroneously expand d -> dev/
        compopt +o filenames
        # However, if any of the COMPREPLY values contains characters that need escaping revert
        # to using filenames (which will handle the escaping: wit<tab> -> with\ space)
        local _sa_valid_value
        local _sa_no_escape_chars_regex='^[a-zA-Z0-9_]*$'
        for _sa_compreply_value in "${COMPREPLY[@]}"
        do
            #SA_COV
            if ! [[ "${_sa_compreply_value}" =~ ${_sa_no_escape_chars_regex} ]]
            then
                #SA_COV
                compopt -o filenames
                break
            fi
        done
    else
        #SA_COV
        # No valid values defined: provide file values as completions (and possibly
        # filter out values that do not pass the validation rules.)

        # If the completed value is a non-existing file or dir (!exists, !file, !dir)
        # generate all files as completions and do not filter based on validation rules.
        # This facilitates the following use case
        # > cp my-data.txt my-da<tab>
        # > cp my-data.txt my-data.txt
        # > cp my-data.txt my-data.txt.bkp
        # (Even if the value cannot be the completion value per se it might be derived
        # from the completion value for example by adding a suffix.)
        _sa_tty_echo CONFIG "${ind}${ind}no valid values defined, check validation rules:"
        local complete_every_file=false
        local validation_array_name
        for validation_array_name in ${entry[validationarraynames]}
        do
            #SA_COV
            declare -n validation_array=${validation_array_name}
            _sa_tty_echo CONFIG -n "${ind}${ind}${ind}${validation_array[*]} (negate: ${sa_validation_command_modifiers[${validation_array_name}_negate]})"
            if { [ "${validation_array[0]}" = "exists" ] ||
                     [ "${validation_array[0]}" = "file" ] ||
                     [ "${validation_array[0]}" = "dir" ]; } &&
                   [ "${sa_validation_command_modifiers[${validation_array_name}_negate]}" = "true" ]
            then
                #SA_COV
                _sa_tty_echo CONFIG " (complete every file)"
                complete_every_file=true
            else
                #SA_COV
                _sa_tty_echo CONFIG ""
            fi
        done

        # Complete file values even if nothing implies that this is a file value
        # since this is the expected behaviour:
        # > sa_parse "$0" <input file>
        # The parameter has no additional information about its nature. However,
        # the parameter is likely to be a file and if it isn't there is no harm
        # in providing file completions.
        _sa_tty_echo CONFIG "complete files"
        # Set IFS temporarily to newline to handle file names with spaces correctly
        IFS=$'\n'
        declare -a compreply_candidates=( $(compgen -f -- "${current_value}") )
        unset IFS
        declare -p compreply_candidates | _sa_tty_echo FINER

        sa_tic_time completion_filter_candidates
        # Decide which candidate completions to show to the user
        COMPREPLY=()
        local sa_candidate
        for sa_candidate in "${compreply_candidates[@]}"
        do
            #SA_COV
            # Replace ~ with ${HOME}
            # This allows auto completing e.g. ~/bin/sc<tab> --> /home/nick/bin/script
            # Note that ${HOME}/bin/sc<tab> behaviour depends on direxpand shell option (shopt)
            sa_candidate="${sa_candidate/#\~/${HOME}}"

            if [[ "${sa_candidate}" = *"*" ]]
            then
                #SA_COV
                _sa_tty_echo FINER "${ind}${ind}candidate: '${sa_candidate}' (ends in '*': filtering out)"
            elif ${complete_every_file}
            then
                #SA_COV
                _sa_tty_echo FINER "${ind}${ind}candidate: '${sa_candidate}' (OK, completing every file)"
                COMPREPLY+=( "${sa_candidate}" )
            elif [ -d "${sa_candidate}" ]
            then
                #SA_COV
                _sa_tty_echo FINER "${ind}${ind}candidate: '${sa_candidate}' (OK, directory)"
                COMPREPLY+=( "${sa_candidate}" )
            else
                #SA_COV
                # Filter out candidate completions that fail the validation.
                declare -a validation_errors=()
                sa_validate_validationarray sa_candidate "${mapname}" "${entry[id]}"

                if [ "${#validation_errors[@]}" -eq 0 ]
                then
                    #SA_COV
                    _sa_tty_echo FINER "${ind}${ind}candidate: '${sa_candidate}' (OK)"
                    COMPREPLY+=( "${sa_candidate}" )
                else
                    #SA_COV
                    _sa_tty_echo FINER "${ind}${ind}candidate: '${sa_candidate}' (FAIL)"
                    local validation_error
                    for validation_error in "${validation_errors[@]}"
                    do
                        #SA_COV
                        _sa_tty_echo FINEST "${ind}${ind}${ind} ${validation_error}"
                    done
                fi
            fi
        done
        sa_toc_time completion_filter_candidates
        compopt -o filenames

        # Covers the cases where user types something like
        # > command $HOME/bi<tab>
        # The COMPREPLY array is left empty since the globbing
        # is tried on literal $HOME/bi* (environment variable
        # unexpanded). So, let Readline's default completion
        # make the initial completion into something like
        # > command /home/jack/bin/
        # and continue with the custom completion from there
        # onwards. Note that the user should have direxpand
        # option set
        # > shopt -s direxpand
        #
        # Bash manual:
        # direxpand
        # If set, Bash replaces directory names with the results
        # of word expansion when performing filename completion.
        # This changes the contents of the readline editing
        # buffer. If not set, Bash attempts to preserve what
        # the user typed.
        if [ ${#COMPREPLY[*]} -eq 0 ]
        then
            #SA_COV
            # TODO: revise if condition
            _sa_tty_echo FINE "${ind}Running: envsubst --variables -- \"${current_value}\""
            if [ "$(envsubst --variables -- "${current_value}" | wc -l)" -gt 0 ] ||
                   grep --silent '^~' <<< "${current_value}" ||
                   grep --silent '^${' <<< "${current_value}"
            then
                #SA_COV
                _sa_tty_echo FINE "${ind}No completions and current value contains an environment variable or tilde: use Bash default completion"
                _sa_tty_echo FINE "${ind}${ind}$(envsubst --variables -- "${current_value}")"

                # Prevent this:
                # > myscript $HOM<tab>
                # > myscript \$HOM
                compopt +o filenames
                # Enable completion of shell variables
                compopt -o bashdefault
                # Enable this:
                # > myscript $HOME/<tab>
                # > myscript /home/jack/
                compopt -o plusdirs
            fi
        fi
    fi
}

# TODO: test:
# process-text-files --path $HO<tab>
# process-text-files $HO<tab>
# process-text-files ${HO<tab>
# process-text-files --path ${HO<tab>
# validationexample --sort=ye<tab>

# Usage: _sa_tty_echo <log level> <message>
# log_level: a positive integer or symbolic name (ERROR, WARN, ...)
_sa_tty_echo() {
    [ -n "${_sa_completion_tty}" ] || return 0
    if [ $# -eq 0 ]
    then
        echo "Usage: ${FUNCNAME} <log level> <message>" >&2
        echo "e.g. ${FUNCNAME} 5 \"Hello world!\""
        return 1
    fi
    local msg_level="$1"; shift
    if ! [ "${msg_level}" -eq "${msg_level}" ] 2>/dev/null
    then
        case "${msg_level}" in
            ERROR) msg_level=70;;
            WARN) msg_level=60;;
            INFO) msg_level=50;;
            CONFIG) msg_level=40;;
            FINE) msg_level=30;;
            FINER) msg_level=20;;
            FINEST) msg_level=10;;
            *) echo "${FUNCNAME}: Invalid log level '${msg_level}'" >&2
               return 1
               ;;
        esac
    fi

    if [ -z "${_sa_ttyecho_level}" ] || [ "${msg_level}" -ge "${_sa_ttyecho_level}" ]
    then
        if [ $# -eq 0 ]
        then
            cat >> "${_sa_completion_tty}"
        else
            echo "$@" >> "${_sa_completion_tty}"
        fi
    fi
    return 0
}

# > _simpleargs_print_ruler 16 "myscript --foo l"
# 0         1
# 01234567890123456789
#                 |
# myscript --foo l
_simpleargs_print_ruler() {
    local last="$1"
    local line="$2"
    local tens=0

    # Print "tens" (the first row)
    if [ "${last}" -ge 10 ]
    then
        while [ $((tens * 10)) -le "${last}" ]
        do
            printf "${tens}         "
            ((tens++))
        done
        echo
    fi

    # Print ones (the second row)
    tens=0
    while [ $((10 * tens)) -le "${last}" ]
    do
        printf "0123456789"
        ((tens++))
    done
    echo

    # Print "cursor position" (the third row)
    printf "%*s\n" "$((last + 1))" "|"

    # Print the command line (the last row)
    if [ -n "${line}" ]
    then
        printf "%s\n" "${line}"
    fi
}

sa_validate_validationarray() {
    local var_name="$1"
    local mapname="$2"
    local entry_label="$3"

    declare -n current_entry="${mapname}"
    declare -n var_value="${var_name}"

    if [ -n "${current_entry[validationarraynames]}" ]
    then
        log FINER "Validating against validation array: '${entry_label}'"
        local validation_array_name
        for validation_array_name in ${current_entry[validationarraynames]}
        do
            sa_validate_command "${entry_label}" "${validation_array_name}" "${var_name}" "${sa_validation_command_modifiers[${validation_array_name}_negate]}"
            local result=$?
            if [ "${result}" -eq "${SA_INCORRECT_USE}" ]
            then
                return "${SA_INCORRECT_USE}"
            elif [ "${result}" -ne 0 ] && [ "${_sa_short_circuit_validation}" = "true" ]
            then
                # Provide "short circuit" option to stop at the first failure. This can be
                # used to speed up auto completion (which doesn't care about the other errors).
                return ${result}
            fi
        done
    fi
}
sa_validate_command() {
    local return_value=0
    local entry="$1" # Option: flag given, Parameter: fullname
    local command_array_name="$2"
    local var_name="$3"
    local negate="$4" # 'true' or 'false'
    declare -n var_value="${var_name}"

    # Use sa_validate_${command[0]} if it exists: e.g. 'int' -> call 'sa_validate_int'
    declare -n command=${command_array_name}
    type "sa_validate_${command[0]}" >/dev/null 2>&1 && command[0]="sa_validate_${command[0]}"
    log FINER "${entry}: Validating '${command_array_name}' (negate: ${negate})"
    log_vars FINER ${command_array_name}

    plus_indent
    local given_value
    # Note, "${var_value[@]}" works for arrays (expands to all values in the array)
    # AND ordinary variables (expands to the single value)
    for given_value in "${var_value[@]}"
    do
        log FINEST "Validating value: '${given_value}'"

        if type "${command[0]}" >/dev/null 2>&1
        then
            "${command[@]}" "${given_value}"
            local validation_result=$?
            if [ "${validation_result}" -eq "${SA_INCORRECT_USE}" ]
            then
                log FINEST "Validation command (${command[0]}) returned ${SA_INCORRECT_USE} (incorrect usage)"
                validation_errors=( "Incorrect usage of validation function: '${command[0]}'" )
                return "${SA_INCORRECT_USE}"
            fi

            ${negate} && validation_result=$( [ ${validation_result} -eq 0 ] && echo 1 || echo 0)

            if [ ${validation_result} -ne 0 ]
            then
                if [ "${_sa_dummy_validation_error_messages}" = "true" ]
                then
                    # Speed up execution when the error message is not needed
                    # (for other than signaling a validation failure).
                    validation_errors+=( "dummy error" )
                else
                    log FINEST "Validation failed (${validation_result})"
                    local error_msg_generation_status
                    unset sa_error_msg
                    if ${negate}
                    then
                        sa_gen_negated_error_msg=true "${command[@]}" "${given_value}"
                        error_msg_generation_status=$?
                    else
                        sa_gen_normal_error_msg=true "${command[@]}" "${given_value}"
                        error_msg_generation_status=$?
                    fi

                    if [ "${error_msg_generation_status}" -eq "${SA_GENERATED_ERROR_MSG_STATUS}" ]
                    then
                        log FINEST "Using custom error message: '${sa_error_msg}'"
                        validation_errors+=("${entry}: ${sa_error_msg}")
                    else
                        log FINEST "Using standard error message"
                        validation_errors+=("${entry}: value '${given_value}' failed validation for $($negate && printf "(not) ")'${command[*]}'")
                    fi
                fi
                return_value=1
            fi
        else
            validation_errors+=("${entry}: No such validation command: '${command}'")
            return_value=1
            break
        fi
    done
    minus_indent
    return "${return_value}"
}

#!/usr/bin/env bash
# simpleargs-validation-functions

sa_validate_grep() {
    if [ $# -ne 2 ]
    then
        echo "${FUNCNAME}: incorrect number ($#) of parameters (should be 2)" >&2
        return "${SA_INCORRECT_USE}"
    fi
    local pattern="$1"
    local value="$2"

    [ "${sa_gen_normal_error_msg}" = "true" ] && { sa_error_msg="'${value}' does not match regular expression '${pattern}'"; return "${SA_GENERATED_ERROR_MSG_STATUS}"; }
    [ "${sa_gen_negated_error_msg}" = "true" ] && { sa_error_msg="'${value}' matches regular expression '${pattern}'"; return "${SA_GENERATED_ERROR_MSG_STATUS}"; }

    #log FINEST "Validating value '${value}' against regexp '${pattern}'"
    grep -q -e "${pattern}" <<< "${value}"
}

sa_validate_egrep() {
    if [ $# -ne 2 ]
    then
        echo "${FUNCNAME}: incorrect number ($#) of parameters (should be 2)" >&2
        return "${SA_INCORRECT_USE}"
    fi
    local pattern="$1"
    local value="$2"

    [ "${sa_gen_normal_error_msg}" = "true" ] && { sa_error_msg="'${value}' does not match extended regular expression '${pattern}'"; return "${SA_GENERATED_ERROR_MSG_STATUS}"; }
    [ "${sa_gen_negated_error_msg}" = "true" ] && { sa_error_msg="'${value}' matches extended regular expression '${pattern}'"; return "${SA_GENERATED_ERROR_MSG_STATUS}"; }

    #log FINEST "Validating value '${value}' against extended regexp '${pattern}'"
    grep -qE -e "${pattern}" <<< "${value}"
}

sa_validate_glob() {
    if [ $# -ne 2 ]
    then
        echo "${FUNCNAME}: incorrect number ($#) of parameters (should be 2)" >&2
        return "${SA_INCORRECT_USE}"
    fi
    local extended_glob="$1"
    local filepath="$2"
    local filename="$(basename "${filepath}")"
    [ "${sa_gen_normal_error_msg}" = "true" ] && { sa_error_msg="'${filename}' does not match glob '${extended_glob}'"; return "${SA_GENERATED_ERROR_MSG_STATUS}"; }
    [ "${sa_gen_negated_error_msg}" = "true" ] && { sa_error_msg="'${filename}' matches glob '${extended_glob}'"; return "${SA_GENERATED_ERROR_MSG_STATUS}"; }

    #log FINEST "Validating value '${value}' against glob '${extended_glob}'"
    (
        LC_COLLATE=C
        [[ "${filename}" = ${extended_glob} ]]
    )
}

sa_validate_filetype() {
    if [ $# -ne 2 ]
    then
        echo "${FUNCNAME}: incorrect number ($#) of parameters (should be 2)" >&2
        return "${SA_INCORRECT_USE}"
    fi
    local filetype_string="$1"
    local filename="$2"

    local filetype="$(file --brief --dereference "${filename}" 2>/dev/null)"
    [ "${sa_gen_normal_error_msg}" = "true" ] && { sa_error_msg="'${filename}' is not of type '${filetype_string}' (but '${filetype}')"; return "${SA_GENERATED_ERROR_MSG_STATUS}"; }
    [ "${sa_gen_negated_error_msg}" = "true" ] && { sa_error_msg="'${filename}' is of type '${filetype_string}'"; return "${SA_GENERATED_ERROR_MSG_STATUS}"; }

    [[ "${filetype}" =~ ${filetype_string} ]]
}

sa_validate_exists() {
    if [ $# -ne 1 ]
    then
        echo "${FUNCNAME}: incorrect number ($#) of parameters (should be 1)" >&2
        return "${SA_INCORRECT_USE}"
    fi

    local filename="$1"
    [ "${sa_gen_normal_error_msg}" = "true" ] && { sa_error_msg="No such file: '${filename}'"; return "${SA_GENERATED_ERROR_MSG_STATUS}"; }
    [ "${sa_gen_negated_error_msg}" = "true" ] && { sa_error_msg="File exists: '${filename}'"; return "${SA_GENERATED_ERROR_MSG_STATUS}"; }
    [ -e "$1" ]
}

sa_validate_file() {
    if [ $# -ne 1 ]
    then
        echo "${FUNCNAME}: incorrect number ($#) of parameters (should be 1)" >&2
        return "${SA_INCORRECT_USE}"
    fi

    local filename="$1"
    [ "${sa_gen_normal_error_msg}" = "true" ] && { sa_error_msg="No such (ordinary) file: '${filename}'"; return "${SA_GENERATED_ERROR_MSG_STATUS}"; }
    [ "${sa_gen_negated_error_msg}" = "true" ] && { sa_error_msg="(Ordinary) file exists: '${filename}'"; return "${SA_GENERATED_ERROR_MSG_STATUS}"; }
    [ -f "$1" ]
}

sa_validate_dir() {
    if [ $# -ne 1 ]
    then
        echo "${FUNCNAME}: incorrect number ($#) of parameters (should be 1)" >&2
        return "${SA_INCORRECT_USE}"
    fi

    local filename="$1"
    [ "${sa_gen_normal_error_msg}" = "true" ] && { sa_error_msg="No such directory: '${filename}'"; return "${SA_GENERATED_ERROR_MSG_STATUS}"; }
    [ "${sa_gen_negated_error_msg}" = "true" ] && { sa_error_msg="Directory exists: '${filename}'"; return "${SA_GENERATED_ERROR_MSG_STATUS}"; }
    [ -d "$1" ]
}

sa_validate_notempty() {
    if [ $# -ne 1 ]
    then
        echo "${FUNCNAME}: incorrect number ($#) of parameters (should be 1)" >&2
        return "${SA_INCORRECT_USE}"
    fi

    local filename="$1"
    [ "${sa_gen_normal_error_msg}" = "true" ] && { sa_error_msg="No such file or not empty: '${filename}'"; return "${SA_GENERATED_ERROR_MSG_STATUS}"; }
    [ "${sa_gen_negated_error_msg}" = "true" ] && { sa_error_msg="Non-empty file exists: '${filename}'"; return "${SA_GENERATED_ERROR_MSG_STATUS}"; }
    [ -s "$1" ]
}

sa_validate_readable() {
    if [ $# -ne 1 ]
    then
        echo "${FUNCNAME}: incorrect number ($#) of parameters (should be 1)" >&2
        return "${SA_INCORRECT_USE}"
    fi

    local filename="$1"
    [ "${sa_gen_normal_error_msg}" = "true" ] && { sa_error_msg="No such file or not readable: '${filename}'"; return "${SA_GENERATED_ERROR_MSG_STATUS}"; }
    [ "${sa_gen_negated_error_msg}" = "true" ] && { sa_error_msg="Readable file exists: '${filename}'"; return "${SA_GENERATED_ERROR_MSG_STATUS}"; }
    [ -r "$1" ]
}

sa_validate_writable() {
    if [ $# -ne 1 ]
    then
        echo "${FUNCNAME}: incorrect number ($#) of parameters (should be 1)" >&2
        return "${SA_INCORRECT_USE}"
    fi

    local filename="$1"
    [ "${sa_gen_normal_error_msg}" = "true" ] && { sa_error_msg="No such file or not writable: '${filename}'"; return "${SA_GENERATED_ERROR_MSG_STATUS}"; }
    [ "${sa_gen_negated_error_msg}" = "true" ] && { sa_error_msg="Writable file exists: '${filename}'"; return "${SA_GENERATED_ERROR_MSG_STATUS}"; }
    [ -w "$1" ]
}

sa_validate_executable() {
    if [ $# -ne 1 ]
    then
        echo "${FUNCNAME}: incorrect number ($#) of parameters (should be 1)" >&2
        return "${SA_INCORRECT_USE}"
    fi

    local filename="$1"
    [ "${sa_gen_normal_error_msg}" = "true" ] && { sa_error_msg="No such file or not executable: '${filename}'"; return "${SA_GENERATED_ERROR_MSG_STATUS}"; }
    [ "${sa_gen_negated_error_msg}" = "true" ] && { sa_error_msg="Executable file exists: '${filename}'"; return "${SA_GENERATED_ERROR_MSG_STATUS}"; }
    [ -x "$1" ]
}

sa_validate_int() {
    local usage="Usage: ${FUNCNAME} [<bounds>] <int> (got: $*)
 - range: [<min>]..[<max>], lower and upper bounds (inclusive)
   e.g. '0..10' or '-10..' or '..13' ('..' is the same as omitting bounds)
 -   int: integer value (in format accepted by Bash) to be tested
   e.g. '0' or '-12' or '+3'"

    local value
    local bounds
    local status=0
    local valid_integer=true

    if [ $# -eq 1 ]
    then
        value="$1"
    elif [ $# -eq 2 ]
    then
        bounds="$1"
        value="$2"
        [[ "${bounds}" != *..* ]] && { echo "${usage}" >&2; return 2; }

        # If there is neither min nor max value make 'bounds' empty
        # to signal that the value (integer) should be checked only for validity.
        [ "${bounds}" = ".." ] && bounds=""
    else
        echo "${FUNCNAME}: incorrect number ($#) of parameters (should be 1 or 2)" >&2
        echo "${usage}" >&2
        return "${SA_INCORRECT_USE}"
    fi

    if [ "${value}" -eq "${value}" ] 2>/dev/null
    then
        true
    else
        valid_integer=false
        status=1
    fi

    if ${valid_integer} && [ -n "${bounds}" ]
    then
        local min=${bounds%%..*} # '1'
        local max=${bounds##*..} # '6'

        if { [ -z "${min}" ] || [ "${value}" -ge "${min}" ]; } &&
           { [ -z "${max}" ] || [ "${value}" -le "${max}" ]; }
        then
            status=0
        else
            status=1
        fi
    fi

    # Normal (positive) error message: either the integer was invalid or it was not in the given range
    if [ "${sa_gen_normal_error_msg}" = "true" ]
    then
        if ${valid_integer}
        then
            if [ -n "${min}" ] && [ -n "${max}" ]
            then
                sa_error_msg="Value '${value}' not in range: ${bounds}"
            else
                [ -n "${min}" ] && sa_error_msg="Value '${value}' less than ${min}"
                [ -n "${max}" ] && sa_error_msg="Value '${value}' greater than ${max}"
            fi
        else
            sa_error_msg="Invalid integer value: '${value}'"
        fi
        return "${SA_GENERATED_ERROR_MSG_STATUS}"
    fi

    # Negative error message: the ingeger was valid (and in the given range)
    if [ "${sa_gen_negated_error_msg}" = "true" ]
    then
        if [ -n "${bounds}" ]
        then
            if [ -n "${min}" ] && [ -n "${max}" ]
            then
                sa_error_msg="Value '${value}' should not be an integer in range ${bounds}"
            else
                [ -n "${min}" ] && sa_error_msg="Value '${value}' should not be greater than or equal to ${min}"
                [ -n "${max}" ] && sa_error_msg="Value '${value}' should not be less than or equal to ${max}"
            fi
        else
            sa_error_msg="Value '${value}' should not be a valid integer"
        fi
        return "${SA_GENERATED_ERROR_MSG_STATUS}"
    fi

    return "${status}"
}

sa_validate_float() {
    local usage="Usage: ${FUNCNAME} [<bounds>] <float> (got: $*)
 - range: [<min>]..[<max>], lower and upper bounds (inclusive)
   e.g. '0..10E1' or '-1.8..12.3' or '-119e-2..13' ('..' is the same as omitting bounds)
 -   float: floating point value in simple or scientific notation to be tested
   e.g. '1.3' or '-12e2' or '+3E-2'"

    local decimal_places=20
    local value original_value bounds
    local status=0
    local valid_float=true

    if [ $# -eq 1 ]
    then
        value="$1"
    elif [ $# -eq 2 ]
    then
        bounds="$1"
        value="$2"
        [[ "${bounds}" != *..* ]] && { echo "${usage}" >&2; return 2; }

        # If there is neither min nor max value make 'bounds' empty
        # to signal that the value (float) should be checked only for validity.
        [ "${bounds}" = ".." ] && bounds=""
    else
        echo "${FUNCNAME}: incorrect number ($#) of parameters (should be 1 or 2)" >&2
        echo "${usage}" >&2
        return "${SA_INCORRECT_USE}"
    fi
    original_value="${value}"

    # http://www.regular-expressions.info/floatingpoint.html
    if grep -E '^[-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?$' <<< "${value}" >/dev/null
    then
        true
    else
        valid_float=false
        status=1
    fi

    if ${valid_float} && [ -n "${bounds}" ]
    then
        local min=${bounds%%..*} # '-2.9e3'
        local max=${bounds##*..} # '+13E1'
        local original_min="${min}"
        local original_max="${max}"

        value="$(printf "%.${decimal_places}f" "${value}")"
        [ $? -eq 0 ] || { echo "${usage}" >&2; return 2; }

        # Convert value, min and max to format understood by bc
        # https://stackoverflow.com/a/12882612 (bc does not understand scientific notation)
        if [ -n "${min}" ]
        then
            if grep -E '^[-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?$' <<< "${min}" >/dev/null
            then
                min="$(printf "%.${decimal_places}f" "${min}")" || { echo "${usage}" >&2; return 2; }
                [ "$(bc <<< "${value} >= ${min}")" -eq 1 ] || status=1
            else
                echo "Malformed min value: '${min}'" >&2
                echo "${usage}" >&2; return 2
            fi
        fi
        if [ -n "${max}" ]
        then
            if grep -E '^[-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?$' <<< "${max}" >/dev/null
            then
                max="$(printf "%.${decimal_places}f" "${max}")" || { echo "${usage}" >&2; return 2; }
                [ "$(bc <<< "${value} <= ${max}")" -eq 1 ] || status=1
            else
                echo "Malformed max value: '${max}'" >&2
                echo "${usage}" >&2; return 2
            fi
        fi
    fi

    # Normal (positive) error message: either the float was invalid or it was not in the given range
    if [ "${sa_gen_normal_error_msg}" = "true" ]
    then
        if ${valid_float}
        then
            if [ -n "${min}" ] && [ -n "${max}" ]
            then
                sa_error_msg="Value '${original_value}' not in range: ${bounds}"
            else
                [ -n "${min}" ] && sa_error_msg="Value '${original_value}' less than ${original_min}"
                [ -n "${max}" ] && sa_error_msg="Value '${original_value}' greater than ${original_max}"
            fi
        else
            sa_error_msg="Invalid float value: '${original_value}'"
        fi
        return "${SA_GENERATED_ERROR_MSG_STATUS}"
    fi

    # Negative error message: the ingeger was valid (and in the given range)
    if [ "${sa_gen_negated_error_msg}" = "true" ]
    then
        if [ -n "${bounds}" ]
        then
            if [ -n "${min}" ] && [ -n "${max}" ]
            then
                sa_error_msg="Value '${original_value}' should not be a float in range ${bounds}"
            else
                [ -n "${min}" ] && sa_error_msg="Value '${original_value}' should not be greater than or equal to ${original_min}"
                [ -n "${max}" ] && sa_error_msg="Value '${original_value}' should not be less than or equal to ${original_max}"
            fi
        else
            sa_error_msg="Value '${original_value}' should not be a valid float"
        fi
        return "${SA_GENERATED_ERROR_MSG_STATUS}"
    fi

    return "${status}"
}

#!/usr/bin/env bash

# Utility to allow a function to return a value by either echoing it
# or by storing it into a variable. Normally the value is echoed but
# if variable "__retname" is defined the value is stored into a variable
# whose name is the contents of __retname. So, if a function is defined as
#
# foo() {
#   local result="..."
#   echo_or_store "${result}"
# }
#
# and one wants to get the result value into a variable (instead of echoing it):
#
# __retname=fooResult foo
# doSomething "${fooResult}"
sa_echo_or_store() {
    local __retval="$1"
    local __retcode="${2:-0}"
    if [ -n "$__retname" ]
    then
        declare -n return_tmp="${__retname}"
        return_tmp="${__retval}"
    else
        echo "$__retval"
    fi
    return "$__retcode"
}

# Return current time in milliseconds
sa_current_time_millis() { sa_echo_or_store $(date +%s%3N); }

# Stopwatch usage:
# sa_stopwatch_reset important
# for i in ...
# do
#     do-something
#     do-something-else
#
#     # Measure how much time is spent in 'do-something-important'
#     sa_stopwatch_start important
#     do-something-important
#     sa_stopwatch_stop important
# done
# sa_stopwatch_print important # Prints e.g.: 4523 ms (important)

sa_stopwatch_start() {
    declare -n stopwatch_running=_stopwatch_running${1:+_$1}
    if [ "${stopwatch_running}" = "true" ]
    then
        echo "ERROR: Stopwatch already running${1:+ (${1})}" >&2
        return 1
    else
        stopwatch_running=true
        declare -n stopwatch_count=_stopwatch_count${1:+_$1}
        [ -n "${stopwatch_count}" ] || __retname=_stopwatch_count${1:+_$1} sa_echo_or_store 0
        __retname=_sa_stopwatch_start${1:+_$1} sa_current_time_millis
    fi
}

sa_stopwatch_stop() {
    declare -n stopwatch_running=_stopwatch_running${1:+_$1}
    if [ "${stopwatch_running}" != "true" ]
    then
        echo "ERROR: Stopwatch already stopped${1:+ (${1})}" >&2
        return 1
    else
        stopwatch_running=false
        declare -n stopwatch_count=_stopwatch_count${1:+_$1}
        declare -n stopwatch_start=_sa_stopwatch_start${1:+_$1}
        __retname="_stopwatch_count${1:+_$1}" sa_echo_or_store $(( ${stopwatch_count} + $(sa_current_time_millis) - ${stopwatch_start} ))
    fi
}

sa_stopwatch_print() {
    local namespace="$1"
    declare -n tmp_count=_stopwatch_count${namespace:+_${namespace}}
    printf "%s %4d ms${namespace:+ (${namespace})}\n" "-----" "${tmp_count}"
}

sa_stopwatch_reset() {
    declare -n stopwatch_running=_stopwatch_running${1:+_$1}
    declare -n stopwatch_count=_stopwatch_count${1:+_$1}
    stopwatch_running=false
    stopwatch_count=0
}

# Set _tic to current time
# $1: namespace of tic-toc watch (return variables are suffixed with _<namespace>)
sa_tic_time() {
    __retname=_tic${1:+_$1} sa_current_time_millis
}

# Add $1 (milliseconds) to current _tic
# $1: time to add to tic_time (in milliseconds)
# $2: namespace of tic-toc watch (return variables are suffixed with _<namespace>)
sa_tic_time_plus() {
    local added_time="$1"
    (( _tic${2:+_$2} = _tic${2:+_$2} + $added_time ))
}

# Set _toc to the time between _tic and the current time
# $1: namespace of tic-toc watch (return variables are suffixed with _<namespace>)
sa_toc_time() {
    __retname=_toctmp sa_current_time_millis
    (( _toc${1:+_$1} = $(sa_current_time_millis) - _tic${1:+_$1} ))
}

# Set toc_time to the time between tic_time and current time
# and set tic_time to current time
# $1: namespace of tic-toc watch (return variables are suffixed with _<namespace>)
sa_toc_tic_time() {
    sa_toc_time $1
    sa_tic_time $1
}

sa_print_toc_time() {
    local namespace="$1"
    declare -n tmp_toc=_toc${namespace:+_${namespace}}
    printf "%s %4d ms${namespace:+ (${namespace})}\n" "-----" "${tmp_toc}"
}

sa_toc_and_print() {
    local namespace="$1"
    sa_toc_time "${namespace}"
    sa_print_toc_time "${namespace}"
}

sa_ms2s() {
    local ms="$1"
    [ ${#ms} -lt 4 ] && { ms="0000${ms}"; ms=${ms: -4}; }
    sa_echo_or_store "${ms:0:-3}.${ms: -3}"
}

# Example:
# sa_tic_time; sleep 1.34; sa_toc_time; sa_ms2s $_toc
# -> prints e.g. 1.346
#
# OR
# sa_tic_time mytimer; sleep 0.46; sa_toc_time mytimer; sa_ms2s $_toc_mytimer
# -> prints e.g. 0.468
SA_GENERATE_COMPLETION_RUNTIME_EOF
}
sa_toc_time "sourcing_simpleargs"; [ "${sa_benchmark}" = "true" ] && sa_print_toc_time "sourcing_simpleargs"
: # Return 0
